{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>.container { width:80% !important; }</style>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "import random\n",
    "import re\n",
    "import sys\n",
    "import pprint\n",
    "import collections\n",
    "import time\n",
    "import more_itertools as mit\n",
    "from scipy import sparse\n",
    "import pickle\n",
    "\n",
    "from IPython.core.display import display, HTML\n",
    "display(HTML(\"<style>.container { width:80% !important; }</style>\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "def fixCharge(biHeavyAtomList):\n",
    "    # input is list of \"ligand class\"\n",
    "    l1 = biHeavyAtomList[0]\n",
    "    l2 = biHeavyAtomList[1]\n",
    "    TotalCharge = l1.charge  # because all charge is stored on the first atom\n",
    "    bestScore = 10\n",
    "    bestCharges = [TotalCharge, 0]\n",
    "    bestBondOrder = 0\n",
    "    for l1Charge in range(-2, 3):\n",
    "        for l2Charge in range(-2, 3):\n",
    "            if TotalCharge == l1Charge + l2Charge:\n",
    "\n",
    "                numVe1 = (l1.numValE + l1.charge -l1Charge) - 2 * l1.numLP - 2 * l1.numberOfHs\n",
    "                numVe2 = (l2.numValE - l2Charge) - 2 * l2.numLP - 2 * l2.numberOfHs\n",
    "                \n",
    "                thisScore = abs(numVe1 - numVe2)\n",
    "                bondOrder = min(numVe1, numVe2)\n",
    "                if thisScore <= bestScore and bondOrder < 5 and bondOrder >= 0:\n",
    "                    bestScore = thisScore\n",
    "                    bestCharges = [l1Charge, l2Charge]\n",
    "                    bestBondOrder = bondOrder\n",
    "    return (bestBondOrder, bestCharges, bestScore)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "def fixCharge_bident(biHeavyAtomList):\n",
    "    # input is list of \"ligand class\"\n",
    "    l1 = biHeavyAtomList[0]\n",
    "    l2 = biHeavyAtomList[1]\n",
    "    bondScore = 0\n",
    "    TotalCharge = l1.charge\n",
    "\n",
    "    bestCharges = [TotalCharge, 0]\n",
    "    \n",
    "    bestb12 = 5\n",
    "    bestb23 = 5\n",
    "    \n",
    "    bestCharge1 = 55\n",
    "    bestCharge2 = 55\n",
    "    hasSet = False\n",
    "#     print('l1.numLP: ' + str(l1.numLP)+ ' l2.numLP: ' + str(l2.numLP))\n",
    "#     print('l1.charge: ' + str(l1.charge))\n",
    "#     print('l1.numValE: ' + str(l1.numValE)+ ' l2.numValE: ' + str(l2.numValE))\n",
    "#     print('l1.numberOfHs: ' + str(l1.numberOfHs)+' l2.numberOfHs: ' + str(l2.numberOfHs))\n",
    "    for l1Charge in range(-2, 3):\n",
    "        for l2Charge in range(-2, 3):\n",
    "            if TotalCharge == l1Charge + l2Charge: \n",
    "\n",
    "                numVe1 = (l1.numValE + l1.charge - l1Charge) - 2 * l1.numLP - 2 * l1.numberOfHs\n",
    "                numVe2 = (l2.numValE - l2Charge) - 2 * l2.numLP - 2 * l2.numberOfHs\n",
    "\n",
    "#                 print('numVe1 = (l1.numValE + l1.charge - l1Charge) - 2 * l1.numLP - 2 * l1.numberOfHs')\n",
    "#                 print('numVe1: ' + str(numVe1)  +  ' numVe2: ' + str(numVe2))\n",
    "#                 print('ve1+2: ' + str(numVe1) + \" and \" + str(numVe2))    \n",
    "#                 print('l1Charge: ' + str(l1Charge)+ ' l2Charge: ' + str(l2Charge))\n",
    "#                 print('1: ' + l1.name + 'H' + str(l1.numberOfHs) + ' charge=' + str(l1.charge))\n",
    "#                 print('2: ' + l2.name + 'H' + str(l2.numberOfHs) + ' charge=' + str(l2.charge))\n",
    "                \n",
    "                if numVe1 > 0 and numVe2 > 1:\n",
    "#                     print('candidate for bonding')\n",
    "                    b12list = []\n",
    "                    for bo in range(1,numVe2+1):\n",
    "                        b12list.append(np.abs(numVe2 - numVe1 - bo))\n",
    "                    \n",
    "                    b12 = np.argmin(b12list)+1\n",
    "                    b23 = np.min([numVe1, (numVe2 - b12)])\n",
    "                    \n",
    "#                     if b12 < bestb12 and b23 < bestb23:\n",
    "                    if (abs(l1Charge)+abs(l2Charge)) < (abs(bestCharge1)+abs(bestCharge2)):\n",
    "#                         print('best config with b12: ' + str(b12) + ' and  b23: ' +str(b23) )\n",
    "                        bestb12 = b12\n",
    "                        bestb23 = b23\n",
    "                        bestCharge1 = l1Charge\n",
    "                        bestCharge2 = l2Charge  \n",
    "                        bondScore = 1\n",
    "                        if not hasSet:\n",
    "                            hasSet = True\n",
    "                    \n",
    "    if not hasSet:\n",
    "        bestb12 = 0\n",
    "        bestb23 = 0\n",
    "        bestCharge1 = TotalCharge\n",
    "        bestCharge2 = 0\n",
    "\n",
    "    return (bestb12, bestb23, [bestCharge1, bestCharge2], bondScore)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "# SC\n",
    "scSeriesMo = ['[Cl-]', '[OH-]', '[S--]', '[OH2]', '[NH3]',\\\n",
    "               '[PH3]','[SH2]'] #up to NHHH from spectrochemical series, rest heather's excel\n",
    "\n",
    "scSeriesDi = [\n",
    "    '[S-]#[S-]', '[C]#4[N-]', '[N-]#4[C]', '[C+]#[O-]', '[N+]=[O]', '[O-]#[O-]']\n",
    "#              '[C][NH]','[C-][P]','[C][PH]','[C][S]','[N]#[CH]','[N]#[P]','[N+]=[S]',\\\n",
    "#              '[O][C]','[O+][N]','[O+][P]','[O++][P]','[P-]#4[C]','[P]#[CH]','[P]#[N]',\\\n",
    "#              '[P+]=[O]','[P+]=[S]','[S][C]','[S+][N]','[S++][O]','[S+][P]',\\\n",
    "#              '[O-][OH]','[S-][SH]'] # up to O22- is from wiki, rest from heather's table\n",
    "\n",
    "classicBidentates = ['[NH2]-[CH2]-[CH2]-[NH2]']\n",
    "\n",
    "boDict = {\n",
    "    0: '#0',\n",
    "    1: '-',\n",
    "    2: '=',\n",
    "    3: '#',\n",
    "    4: '#4',\n",
    "    5: '#5',\n",
    "    -1: '#-1',\n",
    "}\n",
    "\n",
    "## Electronegativity (Pauling) by atom symbol\n",
    "endict =     { \"H\" : 2.20, \"Li\": 0.98, \"Be\": 1.57, \"B\" : 2.04, \"C\" : 2.55, \"N\" : 3.04, \"O\" : 3.44,\n",
    "     \"F\" : 3.98, \"Na\": 0.93, \"Mg\": 1.31, \"Al\": 1.61, \"Si\": 1.90, \"P\" : 2.19, \"S\" : 2.58,\n",
    "     \"Cl\": 3.16, \"K\" : 0.82, \"Ca\": 1.00, \"Sc\": 1.36, \"Ti\": 1.54, \"V\" : 1.63, \"Cr\": 1.66,\n",
    "    \"Mn\": 1.55, \"Fe\": 1.83, \"Co\": 1.88, \"Ni\": 1.91, \"Cu\": 1.90, \"Zn\": 1.65,  \"Ga\": 1.81,\n",
    "    \"Ge\": 2.01, \"As\": 2.18, \"Se\": 2.55, \"Br\": 2.96, \"Mo\": 2.16, \"Tc\": 2.10, \"Rh\": 2.28,\n",
    "    \"Pd\": 2.20, \"Ag\": 1.93,\"Cd\": 1.69, \"In\": 1.78, \"Sb\": 2.05, \"I\":  2.66, \"Cs\": 0.79, \n",
    "    \"Y\":1.22, \"Zr\":1.33, \"Nb\":1.60, \"Ru\":2.20, \"La\":1.10, \"Hf\":1.30, \"Ta\":1.50, \"W\":2.36, \"Re\":1.90}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "# list of elements with name as key and [total electrons, valence electrons, usually used for bonds] as value\n",
    "elemList = {\n",
    "    'C': [6, 4, 4],\n",
    "    'N': [7, 5, 3],\n",
    "    'O': [8, 6, 2],\n",
    "    'P': [15, 5, 3],\n",
    "    'S': [16, 6, 2]\n",
    "}  # 'Si':[14,4,4],'Cl':[17,7,1]\n",
    "\n",
    "components = \"CNOPS\"\n",
    "chargeList = range(-2, 3)\n",
    "# number of H atoms we are sampling through\n",
    "hList = range(0, 5)\n",
    "\n",
    "\n",
    "class ligand():\n",
    "    def __init__(self, name, numberOfHs, charge):\n",
    "        self.name = name\n",
    "        self.charge = charge\n",
    "        self.numberOfHs = numberOfHs\n",
    "        self.numberOfEs = self.getNumE()\n",
    "        self.getNumE()\n",
    "\n",
    "    def print_name(self):\n",
    "        print(self.name)\n",
    "\n",
    "    def print_charge(self):\n",
    "        print(self.charge)\n",
    "\n",
    "    def print_numberOfHs(self):\n",
    "        print(self.numberOfHs)\n",
    "\n",
    "    # CHARGES\n",
    "    def setCharge(self, charge):\n",
    "        self.charge = charge\n",
    "        self.getNumE()\n",
    "\n",
    "    def incrCharge(self):\n",
    "        self.charge += 1\n",
    "        self.getNumE()\n",
    "\n",
    "    def decrCharge(self):\n",
    "        self.charge -= 1\n",
    "        self.getNumE()\n",
    "\n",
    "    # HYDROGENS\n",
    "    def setH(self, number):\n",
    "        self.numberOfHs = number\n",
    "        self.getNumE()\n",
    "\n",
    "    def addH(self):\n",
    "        self.numberOfHs += 1\n",
    "        self.getNumE()\n",
    "\n",
    "    def rmH(self):\n",
    "        self.numberOfHs -= 1\n",
    "        self.getNumE()\n",
    "\n",
    "    def getNumE(self):\n",
    "        self.numLP = int((elemList[self.name][1] - elemList[self.name][2]) / 2)\n",
    "        self.numValE = elemList[self.name][1]\n",
    "        self.numE = elemList[self.name][0]\n",
    "        mod = self.numberOfHs - self.charge\n",
    "        self.numValE += mod\n",
    "        self.numE += mod\n",
    "\n",
    "    def getSmiles(self):\n",
    "        \"\"\"Generates a SMILES string. The first row adds hydrogen and the second row charges\"\"\"\n",
    "        # self.SMILES = \"[\" + self.name + \"\".join([\"H\" for i in range(0, self.numberOfHs)])\n",
    "        # this is for SMILES with HHH instead of H3 etc.\n",
    "        if self.numberOfHs > 1:\n",
    "            self.SMILES = \"[\" + self.name + \"H\" + str(self.numberOfHs)\n",
    "        elif self.numberOfHs == 1:\n",
    "            self.SMILES = \"[\" + self.name + \"H\"\n",
    "        else:\n",
    "            self.SMILES = \"[\" + self.name\n",
    "        self.SMILES += \"\".join([\n",
    "            \"+\" if self.charge > 0 else \"-\"\n",
    "            for i in range(0, abs(int(self.charge)))\n",
    "        ]) + \"]\"\n",
    "\n",
    "    def testOctetRule(self):\n",
    "        \"\"\"Test whether a mono-heavy-atom ligand fulfills the octet rule. Results < 8 means that there are \n",
    "        too many electrons, result > 8 means that there are not enough electrons.\"\"\"\n",
    "        result = 8 - self.numValE\n",
    "        return (result)\n",
    "\n",
    "    def testValenceShell(self):\n",
    "        \"\"\"Since open shell complexes are difficult to converge in DFT, we restrict ourselves to closed shell ones.\"\"\"\n",
    "        result = int(not self.numValE % 2)\n",
    "        return (result)\n",
    "\n",
    "    def score(self):\n",
    "        \"\"\"The health score helps to prune the full enumeration by setting open shell ligands to zero and \n",
    "        weights ligands with negative charge more than ligands with positive charge. Greater is better in this\n",
    "        score.\"\"\"\n",
    "        #         score = (10-(-1*self.testOctetRule() if self.testOctetRule() < 0 else 0.5*self.testOctetRule())) #*self.testValenceShell() # removed the testValshell bc it is only relevant for the whole ligand\n",
    "        score = 4 - np.abs(int(self.testOctetRule()))\n",
    "        return (score)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "code_folding": [
     0
    ],
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Name: Charge + octet + CA = Score\n",
      "[NH3]: 3 + 4 + 3 = 10\n",
      "[OH-]: 3 + 4 + 3 = 10\n",
      "[OH2]: 3 + 4 + 3 = 10\n",
      "[PH3]: 3 + 4 + 3 = 10\n",
      "[S--]: 3 + 4 + 3 = 10\n",
      "[SH2]: 3 + 4 + 3 = 10\n",
      "======\n",
      "All monoatoms: 125\n",
      "All scored monoatoms: 50\n",
      "All wished for monoatoms (>7): 29\n",
      "======\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca7bed9b0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca739e320>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca7508e80>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# generate exhaustive output list for mono-ligands\n",
    "dictMo = {}\n",
    "scoredDictMo = {}\n",
    "wishedDictMo = {}\n",
    "\n",
    "for elem in elemList.keys():\n",
    "    for charge in chargeList:\n",
    "        l = ligand(elem, 0, 0)\n",
    "        l.setCharge(charge)\n",
    "        for h in hList:\n",
    "            if h:\n",
    "                l.addH()\n",
    "            l.getSmiles()\n",
    "            dictMo[l.SMILES] = [l.numE,l.numValE,l.numLP,l.charge,l.numberOfHs,\\\n",
    "                                l.testOctetRule(),l.testValenceShell(),l.score(),\\\n",
    "                                endict[elem], l.numberOfHs*(endict[elem]-endict[\"H\"]), l.numberOfHs*(endict[elem]*endict[\"H\"])]\n",
    "            \n",
    "for name, line in dictMo.items():\n",
    "    octetScore = line[7]\n",
    "    charge = line[3]\n",
    "    numberOfHs = line[4]\n",
    "    numValE = line[1]\n",
    "    closedShell = int(not((numValE)%2))\n",
    "    # Charge: +1 >= charge >= -3\n",
    "    # Sterics: 4 >= Number of H at Coordinating Atom (CA)\n",
    "    # Closed Shell only\n",
    "    if 1 >= charge and charge >= -3 and closedShell == 1: \n",
    "        \n",
    "        # Charge score\n",
    "        if charge == 1:\n",
    "            scoreCharge = 0\n",
    "        if charge <= 0 and charge >= -2:\n",
    "            scoreCharge = 3\n",
    "        elif charge == -3:\n",
    "            scoreCharge = 0\n",
    "\n",
    "        # CA Sterics Score\n",
    "        if numberOfHs == 4:\n",
    "            scoreCa = 0 \n",
    "        else:\n",
    "            scoreCa = 3\n",
    "    \n",
    "        # Total score\n",
    "        score = scoreCharge + octetScore + scoreCa\n",
    "        \n",
    "        # Dict with only scored ligands\n",
    "        dictMo[name] = line + [scoreCharge] + [octetScore] + [scoreCa] + [score] \n",
    "        scoredDictMo[name] = line + [scoreCharge] + [octetScore] + [scoreCa] + [score] \n",
    "        \n",
    "    else:\n",
    "        score = 0.0\n",
    "        dictMo[name] = line + [0] + [0] + [0] + [score]\n",
    "\n",
    "print(\"Name: Charge + octet + CA = Score\")\n",
    "\n",
    "\n",
    "\n",
    "histCharge = list() # lists of charge, octet difference, occupancy of CA and score to see histograms\n",
    "histOctet = list()\n",
    "histCa = list()\n",
    "histScore = list()\n",
    "histVE = list()\n",
    "thresholdMo = 7 #7 define threshold for wishedDictMo\n",
    "for name, props in scoredDictMo.items():        \n",
    "#     histCharge.append(props[3])\n",
    "#     histOctet.append(props[-3])\n",
    "#     histCa.append(props[-2])\n",
    "    histScore.append(props[-1])\n",
    "    histVE.append(props[1])\n",
    "    \n",
    "    # Populate the wishedDictMo\n",
    "    if props[-1] > thresholdMo: \n",
    "        wishedDictMo[name] = props\n",
    "        histCharge.append(props[3])\n",
    "    \n",
    "    # Evaluate compounds from Spectrochemical Series\n",
    "    for i in range(0, len(scSeriesMo)):\n",
    "        if name == scSeriesMo[i]:\n",
    "            print(name + ': ' +str(props[-4])+\" + \"+str(props[-3])+\" + \"+str(props[-2])+' = '+str(props[-1])) \n",
    "\n",
    "print('======')\n",
    "print(\"All monoatoms: \" + str(len(dictMo)))  \n",
    "print(\"All scored monoatoms: \" + str(len(scoredDictMo)))\n",
    "print(\"All wished for monoatoms (>\" + str(thresholdMo) + \"): \" + str(len(wishedDictMo)))\n",
    "print('======')\n",
    "\n",
    "plt.xlabel('Score')\n",
    "plt.ylabel('Number of MHALs')\n",
    "# plt.yscale('log', nonposy='clip')\n",
    "plt.title('Histogram of Scored Space for MHALs')\n",
    "plt.hist(histScore)\n",
    "plt.savefig('mhal_ss_hist.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "\n",
    "plt.hist2d(histVE, histScore, bins=8, cmap = 'Greys')\n",
    "plt.xlabel('v')\n",
    "plt.ylabel('Score')\n",
    "plt.colorbar()\n",
    "plt.savefig('mhal_ss_score_vs_v_2d_hist.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histCharge)\n",
    "plt.ylabel('Number of MHALs')\n",
    "plt.xlabel('Charge')\n",
    "plt.savefig('mhal_ss_hist_charge.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "# pprint.pprint(re.sub('[\\'()a-z_]',\"\",str(wishedDictMo.keys())))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "# # started to translate every dict to lists for MHALs.\n",
    "# listMo = list()\n",
    "# scoredlistMo = {}\n",
    "# wishedlistMo = {}\n",
    "\n",
    "# smi_ind = 0\n",
    "# listSmi = list()\n",
    "\n",
    "# for elem in elemList.keys():\n",
    "#     for charge in chargeList:\n",
    "#         l = ligand(elem, 0, 0)\n",
    "#         l.setCharge(charge)\n",
    "#         for h in hList:\n",
    "#             if h:\n",
    "#                 l.addH()\n",
    "#             l.getSmiles()\n",
    "#             listMo.append([l.numE,l.numValE,l.numLP,l.charge,l.numberOfHs,\\\n",
    "#                                 l.testOctetRule(),l.testValenceShell(),l.score()])\n",
    "#             listSmi.append(l.SMILES)\n",
    "#             smi_ind += 1\n",
    "            \n",
    "# for line in listMo:\n",
    "#     octetScore = line[7]\n",
    "#     charge = line[3]\n",
    "#     numberOfHs = line[4]\n",
    "#     numValE = line[1]\n",
    "#     closedShell = int(not((numValE)%2))\n",
    "#     # Charge: +1 >= charge >= -3\n",
    "#     # Sterics: 4 >= Number of H at Coordinating Atom (CA)\n",
    "#     # Closed Shell only\n",
    "#     if 1 >= charge and charge >= -3 and closedShell == 1: \n",
    "        \n",
    "#         # Charge score\n",
    "#         if charge == 1:\n",
    "#             scoreCharge = 0\n",
    "#         if charge <= 0 and charge >= -2:\n",
    "#             scoreCharge = 3\n",
    "#         elif charge == -3:\n",
    "#             scoreCharge = 0\n",
    "\n",
    "#         # CA Sterics Score\n",
    "#         if numberOfHs == 4:\n",
    "#             scoreCa = 0 \n",
    "#         else:\n",
    "#             scoreCa = 3\n",
    "    \n",
    "#         # Total score\n",
    "#         score = scoreCharge + octetScore + scoreCa\n",
    "        \n",
    "#         # Dict with only scored ligands\n",
    "#         listMo[name] = line + [scoreCharge] + [octetScore] + [scoreCa] + [score] \n",
    "#         scoredlistMo[name] = line + [scoreCharge] + [octetScore] + [scoreCa] + [score] \n",
    "        \n",
    "#     else:\n",
    "#         score = 0.0\n",
    "#         listMo[name] = line + [0] + [0] + [0] + [score]\n",
    "\n",
    "# print(\"Name: Charge + octet + CA = Score\")\n",
    "\n",
    "\n",
    "\n",
    "# histCharge = list() # lists of charge, octet difference, occupancy of CA and score to see histograms\n",
    "# histOctet = list()\n",
    "# histCa = list()\n",
    "# histScore = list()\n",
    "# histVE = list()\n",
    "# thresholdMo = 7 # define threshold for wishedlistMo\n",
    "# for name, props in scoredlistMo.items():        \n",
    "# #     histCharge.append(props[3])\n",
    "# #     histOctet.append(props[-3])\n",
    "# #     histCa.append(props[-2])\n",
    "#     histScore.append(props[-1])\n",
    "#     histVE.append(props[1])\n",
    "    \n",
    "#     # Populate the wishedlistMo\n",
    "#     if props[-1] > thresholdMo: \n",
    "#         wishedlistMo[name] = props\n",
    "#         histCharge.append(props[3])\n",
    "    \n",
    "#     # Evaluate compounds from Spectrochemical Series\n",
    "#     for i in range(0, len(scSeriesMo)):\n",
    "#         if name == scSeriesMo[i]:\n",
    "#             print(name + ': ' +str(props[-4])+\" + \"+str(props[-3])+\" + \"+str(props[-2])+' = '+str(props[-1])) \n",
    "\n",
    "# print('======')\n",
    "# print(\"All monoatoms: \" + str(len(listMo)))  \n",
    "# print(\"All scored monoatoms: \" + str(len(scoredlistMo)))\n",
    "# print(\"All wished for monoatoms (>\" + str(thresholdMo) + \"): \" + str(len(wishedlistMo)))\n",
    "# print('======')\n",
    "\n",
    "# plt.xlabel('Score')\n",
    "# plt.ylabel('Number of MHALs')\n",
    "# # plt.yscale('log', nonposy='clip')\n",
    "# plt.title('Histogram of Scored Space for MHALs')\n",
    "# plt.hist(histScore)\n",
    "# plt.savefig('mhal_ss_hist.pdf', bbox_inches='tight')\n",
    "# plt.show()\n",
    "\n",
    "\n",
    "# plt.hist2d(histVE, histScore, bins=8, cmap = 'Greys')\n",
    "# plt.xlabel('v')\n",
    "# plt.ylabel('Score')\n",
    "# plt.colorbar()\n",
    "# plt.savefig('mhal_ss_score_vs_v_2d_hist.pdf', bbox_inches='tight')\n",
    "# plt.show()\n",
    "\n",
    "# plt.hist(histCharge)\n",
    "# plt.ylabel('Number of MHALs')\n",
    "# plt.xlabel('Charge')\n",
    "# plt.savefig('mhal_ss_hist_charge.pdf', bbox_inches='tight')\n",
    "# plt.show()\n",
    "\n",
    "# # pprint.pprint(re.sub('[\\'()a-z_]',\"\",str(wishedlistMo.keys())))\n",
    "\n",
    "# for i in reversed(range(thresholdMo, 11)):\n",
    "#     for name, props in wishedlistMo.items():\n",
    "#         if props[-1] == i:\n",
    "#             print(name, end=\": \")\n",
    "#             print(props[-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "code_folding": [
     0
    ],
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# # selection of monos\n",
    "# print('These are the ' + str(len(wishedDictMo)) + ' structure we wish for:')\n",
    "# pprint.pprint(wishedDictMo) as\n",
    "\n",
    "# veMo = {'sixVeMo': 0, 'eightVeMo': 0, 'tenVeMo': 0, 'elseVeMo': 0, 'elseVeMo': 0}\n",
    "# smVeMo = {'smSixVeMo': [], 'smEightVeMo': [], 'smTenVeMo': [], 'smElseVeMo': [], 'smElseVeMo': []}\n",
    "\n",
    "# for name, props in wishedDictMo.items():\n",
    "#     if props[1] == 6:\n",
    "#         veMo['sixVeMo'] += 1\n",
    "#         smVeMo[\"smSixVeMo\"].append(name)\n",
    "#     elif props[1] == 8:\n",
    "#         veMo['eightVeMo'] += 1\n",
    "#         smVeMo[\"smEightVeMo\"].append(name)\n",
    "#     elif props[1] == 10:\n",
    "#         veMo['tenVeMo'] += 1\n",
    "#         smVeMo[\"smTenVeMo\"].append(name)\n",
    "#     else:\n",
    "#         veMo['elseVeMo'] += 1\n",
    "#         smVeMo[\"smElseVeMo\"].append(name)\n",
    "\n",
    "# print('\\n Their distribution for 6, 8, and 10 VE: ')\n",
    "# print(veMo)\n",
    "# print('\\n Their SMILES: ')\n",
    "# pprint.pprint(smVeMo)\n",
    "# print('\\n')\n",
    "\n",
    "# selListMo = list()\n",
    "# rnSixVe = random.sample(range(0, len(smVeMo[\"smSixVeMo\"])), 6)\n",
    "# for i in range(0, len(rnSixVe)):\n",
    "#     selListMo.append(smVeMo[\"smSixVeMo\"][rnSixVe[i]])\n",
    "    \n",
    "# rnEightVe = random.sample(range(0, len(smVeMo[\"smEightVeMo\"])), 10)\n",
    "# for i in range(0, len(rnEightVe)):\n",
    "#     selListMo.append(smVeMo[\"smEightVeMo\"][rnEightVe[i]])\n",
    "    \n",
    "# rnTenVe = random.sample(range(0, len(smVeMo[\"smTenVeMo\"])), 4)\n",
    "# for i in range(0, len(rnTenVe)):\n",
    "#     selListMo.append(smVeMo[\"smTenVeMo\"][rnTenVe[i]])\n",
    "\n",
    "# print('\\n A random sample of these structures (2/3 of each isoelectronic group): ')\n",
    "# pprint.pprint(selListMo)   \n",
    "# print('A total of ' + str(len(selListMo)) + ' Structures.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Name, Score = Polarization + Bond + Charge + VSEPR + CA\n",
      "[C]#4[N-]: 2 + 4 + 3 = 14\n",
      "[C+]#[O-]: 3 + 4 + 3 = 15\n",
      "[N-]#4[C]: 2 + 5 + 3 = 15\n",
      "[N+]=[O]: 0 + 5 + 3 = 13\n",
      "[O-]#[O-]: 2 + 4 + 3 = 14\n",
      "[S-]#[S-]: 2 + 4 + 3 = 14\n",
      "======\n",
      "All diatoms: 5625\n",
      "All scored diatoms: 1171\n",
      "All wished for diatoms (>13): 376\n",
      "======\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca741c940>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7facb046b780>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca7543588>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7facd01fb1d0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[NH2]-[CH3]: 17\n",
      "[NH2]-[NH2]: 17\n",
      "[NH2]-[OH]: 17\n",
      "[NH2]-[PH2]: 17\n",
      "[NH2]-[SH]: 17\n",
      "[OH]-[CH3]: 17\n",
      "[OH]-[NH2]: 17\n",
      "[OH]-[OH]: 17\n",
      "[OH]-[PH2]: 17\n",
      "[OH]-[SH]: 17\n",
      "[PH2]-[CH3]: 17\n",
      "[PH2]-[NH2]: 17\n",
      "[PH2]-[OH]: 17\n",
      "[PH2]-[PH2]: 17\n",
      "[PH2]-[SH]: 17\n",
      "[SH]-[CH3]: 17\n",
      "[SH]-[NH2]: 17\n",
      "[SH]-[OH]: 17\n",
      "[SH]-[PH2]: 17\n",
      "[SH]-[SH]: 17\n",
      "[C]#4[C]: 16\n",
      "[CH]#[CH]: 16\n",
      "[CH2]=[CH2]: 16\n",
      "[CH2+]-[CH4-]: 16\n",
      "[CH]#[N]: 16\n",
      "[CH2]=[NH]: 16\n",
      "[CH2+]-[NH3-]: 16\n",
      "[CH2]=[O]: 16\n",
      "[CH2+]-[OH2-]: 16\n",
      "[CH]#[P]: 16\n",
      "[CH2]=[PH]: 16\n",
      "[CH2+]-[PH3-]: 16\n",
      "[CH2]=[S]: 16\n",
      "[CH2+]-[SH2-]: 16\n",
      "[N]#[CH]: 16\n",
      "[NH]=[CH2]: 16\n",
      "[NH+]-[CH4-]: 16\n",
      "[N]#[N]: 16\n",
      "[NH]=[NH]: 16\n",
      "[NH+]-[NH3-]: 16\n",
      "[NH]=[O]: 16\n",
      "[NH+]-[OH2-]: 16\n",
      "[N]#[P]: 16\n",
      "[NH]=[PH]: 16\n",
      "[NH+]-[PH3-]: 16\n",
      "[NH]=[S]: 16\n",
      "[NH+]-[SH2-]: 16\n",
      "[OH2-]-[CH3]: 16\n",
      "[O]=[CH2]: 16\n",
      "[O+]-[CH4-]: 16\n",
      "[OH2-]-[CH2+]: 16\n",
      "[OH2-]-[NH2]: 16\n",
      "[O]=[NH]: 16\n",
      "[O+]-[NH3-]: 16\n",
      "[OH2-]-[NH+]: 16\n",
      "[OH2-]-[OH]: 16\n",
      "[O]=[O]: 16\n",
      "[O+]-[OH2-]: 16\n",
      "[OH2-]-[O+]: 16\n",
      "[OH2-]-[PH2]: 16\n",
      "[O]=[PH]: 16\n",
      "[O+]-[PH3-]: 16\n",
      "[OH2-]-[PH+]: 16\n",
      "[OH2-]-[SH]: 16\n",
      "[O]=[S]: 16\n",
      "[O+]-[SH2-]: 16\n",
      "[OH2-]-[S+]: 16\n",
      "[P]#[CH]: 16\n",
      "[PH]=[CH2]: 16\n",
      "[PH+]-[CH4-]: 16\n",
      "[P]#[N]: 16\n",
      "[PH]=[NH]: 16\n",
      "[PH+]-[NH3-]: 16\n",
      "[PH]=[O]: 16\n",
      "[PH+]-[OH2-]: 16\n",
      "[P]#[P]: 16\n",
      "[PH]=[PH]: 16\n",
      "[PH+]-[PH3-]: 16\n",
      "[PH]=[S]: 16\n",
      "[PH+]-[SH2-]: 16\n",
      "[SH2-]-[CH3]: 16\n",
      "[S]=[CH2]: 16\n",
      "[S+]-[CH4-]: 16\n",
      "[SH2-]-[CH2+]: 16\n",
      "[SH2-]-[NH2]: 16\n",
      "[S]=[NH]: 16\n",
      "[S+]-[NH3-]: 16\n",
      "[SH2-]-[NH+]: 16\n",
      "[SH2-]-[OH]: 16\n",
      "[S]=[O]: 16\n",
      "[S+]-[OH2-]: 16\n",
      "[SH2-]-[O+]: 16\n",
      "[SH2-]-[PH2]: 16\n",
      "[S]=[PH]: 16\n",
      "[S+]-[PH3-]: 16\n",
      "[SH2-]-[PH+]: 16\n",
      "[SH2-]-[SH]: 16\n",
      "[S]=[S]: 16\n",
      "[S+]-[SH2-]: 16\n",
      "[SH2-]-[S+]: 16\n",
      "[C]#4[C--]: 15\n",
      "[CH2--]#4[C]: 15\n",
      "[CH-]#4[C]: 15\n",
      "[CH2-]#[CH]: 15\n",
      "[C+]#[CH2-]: 15\n",
      "[CH+]=[CH3-]: 15\n",
      "[CH2-]#[C+]: 15\n",
      "[CH2-]#[N]: 15\n",
      "[C+]#[NH-]: 15\n",
      "[CH+]=[NH2-]: 15\n",
      "[C+]#[O-]: 15\n",
      "[CH+]=[OH-]: 15\n",
      "[CH2-]#[P]: 15\n",
      "[C+]#[PH-]: 15\n",
      "[CH+]=[PH2-]: 15\n",
      "[C+]#[S-]: 15\n",
      "[CH+]=[SH-]: 15\n",
      "[NH--]#4[C]: 15\n",
      "[NH2--]#[CH]: 15\n",
      "[N-]#4[C]: 15\n",
      "[NH-]#[CH]: 15\n",
      "[NH2-]=[CH2]: 15\n",
      "[NH2]-[CH4-]: 15\n",
      "[N+]=[CH3-]: 15\n",
      "[NH-]#[C+]: 15\n",
      "[NH2-]=[CH+]: 15\n",
      "[NH2--]#[N]: 15\n",
      "[NH-]#[N]: 15\n",
      "[NH2-]=[NH]: 15\n",
      "[NH2]-[NH3-]: 15\n",
      "[N+]=[NH2-]: 15\n",
      "[NH2-]=[N+]: 15\n",
      "[NH2-]=[O]: 15\n",
      "[NH2]-[OH2-]: 15\n",
      "[N+]=[OH-]: 15\n",
      "[NH2--]#[P]: 15\n",
      "[NH-]#[P]: 15\n",
      "[NH2-]=[PH]: 15\n",
      "[NH2]-[PH3-]: 15\n",
      "[N+]=[PH2-]: 15\n",
      "[NH2-]=[P+]: 15\n",
      "[NH2-]=[S]: 15\n",
      "[NH2]-[SH2-]: 15\n",
      "[N+]=[SH-]: 15\n",
      "[O--]#4[C]: 15\n",
      "[OH--]#[CH]: 15\n",
      "[OH2--]=[CH2]: 15\n",
      "[OH2-]-[CH4-]: 15\n",
      "[O-]#[CH]: 15\n",
      "[OH-]=[CH2]: 15\n",
      "[OH]-[CH4-]: 15\n",
      "[O-]#[C+]: 15\n",
      "[OH-]=[CH+]: 15\n",
      "[OH--]#[N]: 15\n",
      "[OH2--]=[NH]: 15\n",
      "[OH2-]-[NH3-]: 15\n",
      "[O-]#[N]: 15\n",
      "[OH-]=[NH]: 15\n",
      "[OH]-[NH3-]: 15\n",
      "[OH-]=[N+]: 15\n",
      "[OH2--]=[O]: 15\n",
      "[OH2-]-[OH2-]: 15\n",
      "[OH-]=[O]: 15\n",
      "[OH]-[OH2-]: 15\n",
      "[OH--]#[P]: 15\n",
      "[OH2--]=[PH]: 15\n",
      "[OH2-]-[PH3-]: 15\n",
      "[O-]#[P]: 15\n",
      "[OH-]=[PH]: 15\n",
      "[OH]-[PH3-]: 15\n",
      "[OH-]=[P+]: 15\n",
      "[OH2--]=[S]: 15\n",
      "[OH2-]-[SH2-]: 15\n",
      "[OH-]=[S]: 15\n",
      "[OH]-[SH2-]: 15\n",
      "[PH--]#4[C]: 15\n",
      "[PH2--]#[CH]: 15\n",
      "[P-]#4[C]: 15\n",
      "[PH-]#[CH]: 15\n",
      "[PH2-]=[CH2]: 15\n",
      "[PH2]-[CH4-]: 15\n",
      "[P+]=[CH3-]: 15\n",
      "[PH-]#[C+]: 15\n",
      "[PH2-]=[CH+]: 15\n",
      "[PH2--]#[N]: 15\n",
      "[PH-]#[N]: 15\n",
      "[PH2-]=[NH]: 15\n",
      "[PH2]-[NH3-]: 15\n",
      "[P+]=[NH2-]: 15\n",
      "[PH2-]=[N+]: 15\n",
      "[PH2-]=[O]: 15\n",
      "[PH2]-[OH2-]: 15\n",
      "[P+]=[OH-]: 15\n",
      "[PH2--]#[P]: 15\n",
      "[PH-]#[P]: 15\n",
      "[PH2-]=[PH]: 15\n",
      "[PH2]-[PH3-]: 15\n",
      "[P+]=[PH2-]: 15\n",
      "[PH2-]=[P+]: 15\n",
      "[PH2-]=[S]: 15\n",
      "[PH2]-[SH2-]: 15\n",
      "[P+]=[SH-]: 15\n",
      "[S--]#4[C]: 15\n",
      "[SH--]#[CH]: 15\n",
      "[SH2--]=[CH2]: 15\n",
      "[SH2-]-[CH4-]: 15\n",
      "[S-]#[CH]: 15\n",
      "[SH-]=[CH2]: 15\n",
      "[SH]-[CH4-]: 15\n",
      "[S-]#[C+]: 15\n",
      "[SH-]=[CH+]: 15\n",
      "[SH--]#[N]: 15\n",
      "[SH2--]=[NH]: 15\n",
      "[SH2-]-[NH3-]: 15\n",
      "[S-]#[N]: 15\n",
      "[SH-]=[NH]: 15\n",
      "[SH]-[NH3-]: 15\n",
      "[SH-]=[N+]: 15\n",
      "[SH2--]=[O]: 15\n",
      "[SH2-]-[OH2-]: 15\n",
      "[SH-]=[O]: 15\n",
      "[SH]-[OH2-]: 15\n",
      "[SH--]#[P]: 15\n",
      "[SH2--]=[PH]: 15\n",
      "[SH2-]-[PH3-]: 15\n",
      "[S-]#[P]: 15\n",
      "[SH-]=[PH]: 15\n",
      "[SH]-[PH3-]: 15\n",
      "[SH-]=[P+]: 15\n",
      "[SH2--]=[S]: 15\n",
      "[SH2-]-[SH2-]: 15\n",
      "[SH-]=[S]: 15\n",
      "[SH]-[SH2-]: 15\n",
      "[CH-]#4[CH-]: 14\n",
      "[CH2-]#[CH2-]: 14\n",
      "[C]#4[CH-]: 14\n",
      "[CH]#[CH2-]: 14\n",
      "[CH2]=[CH3-]: 14\n",
      "[CH3]-[CH3]: 14\n",
      "[CH2+]-[CH3]: 14\n",
      "[CH-]#4[N-]: 14\n",
      "[CH2-]#[NH-]: 14\n",
      "[C]#4[N-]: 14\n",
      "[CH]#[NH-]: 14\n",
      "[CH2]=[NH2-]: 14\n",
      "[CH3]-[NH2]: 14\n",
      "[CH2+]-[NH2]: 14\n",
      "[CH2-]#[O-]: 14\n",
      "[CH]#[O-]: 14\n",
      "[CH2]=[OH-]: 14\n",
      "[CH3]-[OH]: 14\n",
      "[CH2+]-[OH]: 14\n",
      "[CH-]#4[P-]: 14\n",
      "[CH2-]#[PH-]: 14\n",
      "[C]#4[P-]: 14\n",
      "[CH]#[PH-]: 14\n",
      "[CH2]=[PH2-]: 14\n",
      "[CH3]-[PH2]: 14\n",
      "[CH2+]-[PH2]: 14\n",
      "[CH2-]#[S-]: 14\n",
      "[CH]#[S-]: 14\n",
      "[CH2]=[SH-]: 14\n",
      "[CH3]-[SH]: 14\n",
      "[CH2+]-[SH]: 14\n",
      "[N-]#4[CH-]: 14\n",
      "[NH-]#[CH2-]: 14\n",
      "[NH2-]=[CH3-]: 14\n",
      "[N]#[CH2-]: 14\n",
      "[NH]=[CH3-]: 14\n",
      "[NH+]-[CH3]: 14\n",
      "[N-]#4[N-]: 14\n",
      "[NH-]#[NH-]: 14\n",
      "[NH2-]=[NH2-]: 14\n",
      "[NH2]-[NH4--]: 14\n",
      "[N]#[NH-]: 14\n",
      "[NH]=[NH2-]: 14\n",
      "[NH+]-[NH2]: 14\n",
      "[NH-]#[O-]: 14\n",
      "[NH2-]=[OH-]: 14\n",
      "[NH2]-[OH3--]: 14\n",
      "[N]#[O-]: 14\n",
      "[NH]=[OH-]: 14\n",
      "[NH+]-[OH]: 14\n",
      "[N-]#4[P-]: 14\n",
      "[NH-]#[PH-]: 14\n",
      "[NH2-]=[PH2-]: 14\n",
      "[NH2]-[PH4--]: 14\n",
      "[N]#[PH-]: 14\n",
      "[NH]=[PH2-]: 14\n",
      "[NH+]-[PH2]: 14\n",
      "[NH-]#[S-]: 14\n",
      "[NH2-]=[SH-]: 14\n",
      "[NH2]-[SH3--]: 14\n",
      "[N]#[S-]: 14\n",
      "[NH]=[SH-]: 14\n",
      "[NH+]-[SH]: 14\n",
      "[O-]#[CH2-]: 14\n",
      "[OH-]=[CH3-]: 14\n",
      "[O]=[CH3-]: 14\n",
      "[O+]-[CH3]: 14\n",
      "[O-]#[NH-]: 14\n",
      "[OH-]=[NH2-]: 14\n",
      "[OH]-[NH4--]: 14\n",
      "[O]=[NH2-]: 14\n",
      "[O+]-[NH2]: 14\n",
      "[O-]#[O-]: 14\n",
      "[OH-]=[OH-]: 14\n",
      "[OH]-[OH3--]: 14\n",
      "[O]=[OH-]: 14\n",
      "[O+]-[OH]: 14\n",
      "[O-]#[PH-]: 14\n",
      "[OH-]=[PH2-]: 14\n",
      "[OH]-[PH4--]: 14\n",
      "[O]=[PH2-]: 14\n",
      "[O+]-[PH2]: 14\n",
      "[O-]#[S-]: 14\n",
      "[OH-]=[SH-]: 14\n",
      "[OH]-[SH3--]: 14\n",
      "[O]=[SH-]: 14\n",
      "[O+]-[SH]: 14\n",
      "[P-]#4[CH-]: 14\n",
      "[PH-]#[CH2-]: 14\n",
      "[PH2-]=[CH3-]: 14\n",
      "[P]#[CH2-]: 14\n",
      "[PH]=[CH3-]: 14\n",
      "[PH+]-[CH3]: 14\n",
      "[P-]#4[N-]: 14\n",
      "[PH-]#[NH-]: 14\n",
      "[PH2-]=[NH2-]: 14\n",
      "[PH2]-[NH4--]: 14\n",
      "[P]#[NH-]: 14\n",
      "[PH]=[NH2-]: 14\n",
      "[PH+]-[NH2]: 14\n",
      "[PH-]#[O-]: 14\n",
      "[PH2-]=[OH-]: 14\n",
      "[PH2]-[OH3--]: 14\n",
      "[P]#[O-]: 14\n",
      "[PH]=[OH-]: 14\n",
      "[PH+]-[OH]: 14\n",
      "[P-]#4[P-]: 14\n",
      "[PH-]#[PH-]: 14\n",
      "[PH2-]=[PH2-]: 14\n",
      "[PH2]-[PH4--]: 14\n",
      "[P]#[PH-]: 14\n",
      "[PH]=[PH2-]: 14\n",
      "[PH+]-[PH2]: 14\n",
      "[PH-]#[S-]: 14\n",
      "[PH2-]=[SH-]: 14\n",
      "[PH2]-[SH3--]: 14\n",
      "[P]#[S-]: 14\n",
      "[PH]=[SH-]: 14\n",
      "[PH+]-[SH]: 14\n",
      "[S-]#[CH2-]: 14\n",
      "[SH-]=[CH3-]: 14\n",
      "[S]=[CH3-]: 14\n",
      "[S+]-[CH3]: 14\n",
      "[S-]#[NH-]: 14\n",
      "[SH-]=[NH2-]: 14\n",
      "[SH]-[NH4--]: 14\n",
      "[S]=[NH2-]: 14\n",
      "[S+]-[NH2]: 14\n",
      "[S-]#[O-]: 14\n",
      "[SH-]=[OH-]: 14\n",
      "[SH]-[OH3--]: 14\n",
      "[S]=[OH-]: 14\n",
      "[S+]-[OH]: 14\n",
      "[S-]#[PH-]: 14\n",
      "[SH-]=[PH2-]: 14\n",
      "[SH]-[PH4--]: 14\n",
      "[S]=[PH2-]: 14\n",
      "[S+]-[PH2]: 14\n",
      "[S-]#[S-]: 14\n",
      "[SH-]=[SH-]: 14\n",
      "[SH]-[SH3--]: 14\n",
      "[S]=[SH-]: 14\n",
      "[S+]-[SH]: 14\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7facb0409518>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# generate exhaustive output list for di-ligands\n",
    "dictDi = {}\n",
    "scoredDictDi = {}\n",
    "wishedDictDi = {}\n",
    "\n",
    "for elem1 in elemList.keys():\n",
    "    for elem2 in elemList.keys():\n",
    "        for charge1 in range(\n",
    "                -4, 5\n",
    "        ):  # charge1 on one but from -4 to +4, because charge is not localized in dft\n",
    "            for h1 in hList:\n",
    "                for h2 in hList:\n",
    "                    l1 = ligand(elem1, 0, 0)\n",
    "                    l1.setCharge(charge1)\n",
    "                    l1.setH(h1)\n",
    "                    l2 = ligand(elem2, 0, 0)\n",
    "                    l2.setCharge(0)  # charge should distribute from first atom\n",
    "                    l2.setH(h2)\n",
    "                    bestBondOrder, bestCharges, bestScore = fixCharge([l1, l2])\n",
    "                    l1.setCharge(bestCharges[0])\n",
    "                    l2.setCharge(bestCharges[1])\n",
    "                    l1.getSmiles()\n",
    "                    l2.getSmiles()\n",
    "                    diatomName = ''.join(\n",
    "                        l1.SMILES + boDict[bestBondOrder] + l2.SMILES)\n",
    "                    dictDi[diatomName] = [l1.numE, l1.numValE, l1.numLP, l1.charge, l1.numberOfHs, \\\n",
    "                                         l1.testOctetRule(), l1.testValenceShell(), l1.score(),\\\n",
    "                                         l2.numE, l2.numValE, l2.numLP, l2.charge, l2.numberOfHs, \\\n",
    "                                         l2.testOctetRule(), l2.testValenceShell(), \\\n",
    "                                         bestBondOrder ,l2.score(), endict[elem1], \\\n",
    "                                         endict[elem1]-endict[elem2]+l1.numberOfHs*(endict[elem1]-endict[\"H\"]),\\\n",
    "                                         endict[elem1]*endict[elem2]+l1.numberOfHs*(endict[elem1]*endict[\"H\"])]\n",
    "                                            #15, 16, 17, 18, 19\n",
    "\n",
    "for name, line in dictDi.items():\n",
    "    charge1 = line[3] \n",
    "    charge2 = line[11]\n",
    "    charge = charge1 + charge2\n",
    "    numberOfHs = line[4]\n",
    "    numValE1 = line[1]\n",
    "    numValE2 = line[9]\n",
    "    numLP1 = line[2]\n",
    "    numLP2 = line[10]\n",
    "    bestBondOrder = line[15]\n",
    "    closedShell = int(not ((numValE1 + numValE2) % 2))\n",
    "    # Charge: 1 >= charge >= -4\n",
    "    # Sterics: 4 >= Number of H at CA\n",
    "    # Closed Shell only\n",
    "    if charge <= 1 and numberOfHs < 4 and closedShell == 1 and bestBondOrder > 0:  # overall charge should not exceed +1 and not more than 3 H at CA\n",
    "        \n",
    "        # Polarization\n",
    "        if np.abs(charge1) + np.abs(charge2) == 4:\n",
    "            scorePol = 0\n",
    "        elif np.abs(charge1) + np.abs(charge2) == 3:\n",
    "            scorePol = 1\n",
    "        else:\n",
    "            scorePol = 3\n",
    "        \n",
    "        # Bond score\n",
    "        if bestBondOrder == 1 :\n",
    "            scoreBond = 3\n",
    "        elif bestBondOrder == 4 or bestBondOrder == 2 or bestBondOrder == 3:\n",
    "            scoreBond = 2\n",
    "            \n",
    "        # Charge score\n",
    "        if charge == 1:\n",
    "            scoreCharge = 0\n",
    "        elif charge == 0:\n",
    "            scoreCharge = 3\n",
    "        if charge <= -1 and charge >= -2:\n",
    "            scoreCharge = 2\n",
    "        elif charge == -3:\n",
    "            scoreCharge = 1\n",
    "        elif charge == -4:\n",
    "            scoreCharge = 0\n",
    "\n",
    "        # VSEPR score\n",
    "        # IS THIS THE SAME AS BOND ORDER\n",
    "        usual1 = numValE1 - 2 * numLP1 + charge * 0 - 2 * numberOfHs\n",
    "        usual2 = numValE2 - 2 * numLP2 + line[11] - 2 * line[12]\n",
    "        scoreVsepr = 5 - np.abs(usual1 - usual2)\n",
    "\n",
    "        # CA Sterics Score\n",
    "        if line[4] == 3:\n",
    "            scoreCa = 0\n",
    "        else:\n",
    "            scoreCa = 3\n",
    "\n",
    "        #Total score\n",
    "        score =  scorePol + scoreBond + scoreCharge + scoreVsepr + scoreCa \n",
    "\n",
    "        # Dict with only scored ligands\n",
    "#         dictDi[name] = line + [scorePol] + [scoreCharge] + [scoreVsepr] + [scoreCa] + [score]\n",
    "        scoredDictDi[name] = line + [scorePol] + [scoreBond] + [scoreCharge] + [scoreVsepr] + [scoreCa] + [score]\n",
    "\n",
    "    else:\n",
    "        score = 0.0\n",
    "        dictDi[name] = line + [0] + [0] + [0] + [0] + [0] + [score]\n",
    "\n",
    "print(\"Name, Score = Polarization + Bond + Charge + VSEPR + CA\")\n",
    "\n",
    "histCharge = list()\n",
    "histBO = list()\n",
    "histVsepr = list()\n",
    "histCa = list()\n",
    "histScore = list()\n",
    "histVE = list()\n",
    "thresholdDi = 13 #13\n",
    "histEN = list()\n",
    "\n",
    "for name, props in scoredDictDi.items():\n",
    "#     histBO.append(props[15])\n",
    "#     histCharge.append(props[3]+props[11])\n",
    "#     histVsepr.append(props[-3])\n",
    "#     histCa.append(props[-2])\n",
    "#     histScore.append(props[-1])\n",
    "#     histVE.append(props[1] + props[9])\n",
    "\n",
    "    # populate the wishedDictDi\n",
    "    if props[-1] > thresholdDi:\n",
    "        wishedDictDi[name] = props\n",
    "        histBO.append(props[15])\n",
    "        histCharge.append(props[3]+props[11])\n",
    "        histVsepr.append(props[-3])\n",
    "        histCa.append(props[-2])\n",
    "        histScore.append(props[-1])\n",
    "        histVE.append(props[1] + props[9])\n",
    "        histEN.append(props[17])\n",
    "\n",
    "    # Evaluate compounds from Spectrochemical Series\n",
    "    for i in range(0, len(scSeriesDi)):\n",
    "        if name == scSeriesDi[i]:\n",
    "            print(name + ': ' + str(props[-4]) + \" + \" + str(props[-3]) +\n",
    "                  \" + \" + str(props[-2]) + ' = ' + str(props[-1]))\n",
    "\n",
    "print('======')\n",
    "print(\"All diatoms: \" + str(len(dictDi)))\n",
    "print(\"All scored diatoms: \" + str(len(scoredDictDi)))\n",
    "print(\"All wished for diatoms (>\" + str(thresholdDi) + \"): \" + str(len(wishedDictDi)))\n",
    "print('======')\n",
    "\n",
    "plt.xlabel('Score')\n",
    "plt.ylabel('Number of DHALs')\n",
    "# plt.yscale('log', nonposy='clip')\n",
    "plt.title('Histogram of Scored Space for DHALs')\n",
    "plt.hist(histScore)\n",
    "plt.axvline(thresholdDi, color='black', linestyle='dashed', linewidth=2)\n",
    "plt.savefig('dhal_ss_hist.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist2d(histScore, histVE, cmap = 'Greys')\n",
    "plt.xlabel('score')\n",
    "plt.ylabel('v')\n",
    "# plt.ylim((0,10))\n",
    "# plt.xlim((8,22))\n",
    "plt.savefig('dhal_ss_score_vs_v_2d_hist.pdf', bbox_inches='tight')\n",
    "plt.colorbar()\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histBO)\n",
    "plt.xlabel('BO')\n",
    "plt.ylabel('Number of DHALs')\n",
    "plt.savefig('dhal_ss_hist_bo.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histCharge)\n",
    "plt.xlabel('charge')\n",
    "plt.ylabel('Number of DHALs')\n",
    "plt.savefig('dhal_ss_hist_charge.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "for i in reversed(range(thresholdDi, 18)):\n",
    "    for name, props in wishedDictDi.items():\n",
    "        if props[-1] == i:\n",
    "            print(name, end=\": \")\n",
    "            print(props[-1])\n",
    "\n",
    "    \n",
    "plt.hist(histEN)\n",
    "plt.xlabel('EN')\n",
    "plt.ylabel('Number of DHALs')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "code_folding": [
     0
    ],
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# # selection of di ligands\n",
    "# print('These are the ' + str(len(wishedDictDi)) + ' structure we wish for:')\n",
    "# # pprint.pprint(wishedDictDi)\n",
    "\n",
    "# veDi = {'VeDi8': 0, 'VeDi10': 0, 'VeDi12': 0, 'VeDi14': 0, 'VeDi16': 0, 'VeDi18': 0}\n",
    "# smVeDi = {'smVeDi8': [], 'smVeDi10': [], 'smVeDi12': [], 'smVeDi14': [], 'smVeDi16': [], 'smVeDi18': []}\n",
    "\n",
    "# for name, props in wishedDictDi.items():\n",
    "#     if props[1] + props[9] == 8:\n",
    "#         veDi['VeDi8'] += 1\n",
    "#         smVeDi[\"smVeDi8\"].append(name)\n",
    "#     elif props[1] + props[9] == 10:\n",
    "#         veDi['VeDi10'] += 1\n",
    "#         smVeDi[\"smVeDi10\"].append(name)\n",
    "#     elif props[1] + props[9] == 12:\n",
    "#         veDi['VeDi12'] += 1\n",
    "#         smVeDi[\"smVeDi12\"].append(name)\n",
    "#     elif props[1] + props[9] == 14:\n",
    "#         veDi['VeDi14'] += 1\n",
    "#         smVeDi[\"smVeDi14\"].append(name)\n",
    "#     elif props[1] + props[9] == 16:\n",
    "#         veDi['VeDi16'] += 1\n",
    "#         smVeDi[\"smVeDi16\"].append(name)\n",
    "#     elif props[1] + props[9] == 18:\n",
    "#         veDi['VeDi18'] += 1\n",
    "#         smVeDi[\"smVeDi18\"].append(name)\n",
    "\n",
    "# print('\\n Their distribution for Isoelectronics [8,18]: ')\n",
    "# print(veDi)\n",
    "# print('\\n Their SMILES: ')\n",
    "# # pprint.pprint(smVeDi)\n",
    "# print('\\n')\n",
    "\n",
    "# selListDi = list()\n",
    "# tuplesList = [(8,1),(10,5),(12,20),(14,30),(16,20),(18,4)]\n",
    "# for tuples in tuplesList:\n",
    "#     key = \"smVeDi\"+str(tuples[0])\n",
    "#     randInds = random.sample(range(0, len(smVeDi[key])), tuples[1])\n",
    "#     for inds in randInds:\n",
    "#         selListDi.append(smVeDi[key][inds])\n",
    "\n",
    "# print('\\n A random sample of these structures (1/5 of each isoelectronic group): ')\n",
    "# print(selListDi)   \n",
    "# print('A total of ' + str(len(selListDi)) + ' Structures.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "code_folding": [
     0,
     51
    ]
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The 1st [.] is always the CA and the 2nd [.] is the bridging atom:\n",
      "\n",
      "Name, Score = Polarization (Charge Diff) + CA + Bond + VSEPR \n",
      "[NH2]-[CH2]-[CH2]-[NH2]: 5 + 3 + 3 + 5 = 16\n",
      "\n",
      "======\n",
      "All bidentates: 5625\n",
      "All scored bidentates: 1635\n",
      "All wished for bidentates: 148\n",
      "======\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca72feb70>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7facb04095f8>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYgAAAEKCAYAAAAIO8L1AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMS4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvNQv5yAAAFFFJREFUeJzt3X+0XWV95/H3RyJaWjUgwaYJNNGmtkyrQ+aWwTpLUVoH0AF1aRepgxSZpjNSZdROwbYjbR2nujr+XKvFicAYpxbKIAMZCzN1KOhUCzWIhF8iKSBEorkdrVitPwLf+ePslEtm33MPN3effe6979daZ2XvZ+9z93eHkE+evffz7FQVkiTt7wl9FyBJmkwGhCSplQEhSWplQEiSWhkQkqRWBoQkqZUBIUlqZUBIkloZEJKkViv6LuBAHH744bVu3bq+y5CkReWmm276m6paNdd+izog1q1bx/bt2/suQ5IWlSRfGmU/LzFJkloZEJKkVgaEJKmVASFJamVASJJaGRCSpFYGhCSplQEhSWplQEiSWi3qkdTSJFt33p/2ctz73vnSXo6rpccehCSplQEhSWplQEiSWhkQkqRWBoQkqZUBIUlq1VlAJLk4yZ4kt7Vs+7UkleTwZj1JPpBkZ5IdSTZ2VZckaTRd9iA+DJy4f2OSI4GfB+6f0XwSsKH5bAYu6LAuSdIIOguIqvoU8LWWTe8Ffh2oGW2nAh+pgRuAlUlWd1WbJGluY70HkeQU4MtVdct+m9YAD8xY39W0SZJ6MrapNpIcAvwm8JK2zS1t1dJGks0MLkNx1FFHLVh9kqTHGmcP4lnAeuCWJPcBa4HPJflhBj2GI2fsuxZ4sO2HVNWWqpqqqqlVq1Z1XLIkLV9jC4iqurWqjqiqdVW1jkEobKyqrwDbgNc2TzMdB3yjqnaPqzZJ0v+vy8dcLwH+Enh2kl1Jzhqy+9XAPcBO4EPA67uqS5I0ms7uQVTVpjm2r5uxXMDZXdUiSXr8HEktSWplQEiSWhkQkqRWBoQkqZUBIUlqZUBIkloZEJKkVgaEJKmVASFJamVASJJaGRCSpFYGhCSplQEhSWplQEiSWhkQkqRWBoQkqZUBIUlqZUBIkloZEJKkVp0FRJKLk+xJctuMtt9P8oUkO5L89yQrZ2x7a5KdSe5K8s+7qkuSNJouexAfBk7cr+0TwE9V1XOALwJvBUhyNHAa8I+a7/xhkoM6rE2SNIfOAqKqPgV8bb+2P6uqvc3qDcDaZvlU4NKq+m5V3QvsBI7tqjZJ0tz6vAfxOuCaZnkN8MCMbbuaNklST3oJiCS/CewFPrqvqWW3muW7m5NsT7J9enq6qxIladkbe0AkOQN4GfCaqtoXAruAI2fsthZ4sO37VbWlqqaqamrVqlXdFitJy9hYAyLJicC5wClV9e0Zm7YBpyV5UpL1wAbgr8ZZmyTpsVZ09YOTXAIcDxyeZBdwPoOnlp4EfCIJwA1V9a+r6vYklwF3MLj0dHZVPdxVbZKkuXUWEFW1qaX5oiH7vwN4R1f1SJIeH0dSS5JaGRCSpFYGhCSplQEhSWplQEiSWhkQkqRWBoQkqZUBIUlqZUBIkloZEJKkVgaEJKmVASFJajVnQCR5VpInNcvHJ3ljkpXdlyZJ6tMoPYiPAQ8n+TEGs7GuB/6406okSb0bJSAeqaq9wCuA91XVm4DV3ZYlSerbKAHx/SSbgDOAjzdtT+yuJEnSJBglIM4Enge8o6rubV4J+kfdliVJ6tucb5SrqjuAN85YvzfJMZ1WJUnq3Xwfc33eglYhSZo4nY2DSHJxkj1JbpvRdliSTyS5u/n10KY9ST6QZGeSHUk2dlWXJGk0swZEko2zfP4Jo92k/jBw4n5t5wHXVtUG4NpmHeAkYEPz2Qxc8DjPQ5K0wIbdg3j3kG1fmOsHV9Wnkqzbr/lU4PhmeStwPXBu0/6RqirghiQrk6yuqt1zHUeS1I1ZA6KqXjTbtiTzfcz1Gfv+0q+q3UmOaNrXAA/M2G9X02ZASFJPRr4H0dwneHGSCxn8Bb6Q0tJWs9SxOcn2JNunp6cXuAxJ0j6jzMX0T5O8H/gSsA34P8BPzPN4X02yuvm5q4E9Tfsu4MgZ+60FHmz7AVW1paqmqmpq1apV8yxDkjSXYTep35HkbuA/ArcCxwDTVbW1qr4+z+NtYzAim+bXq2a0v7bppRwHfMP7D5LUr2E3qTcDdzF4oujjVfWdJK2XfdokuYTBDenDk+wCzgfeCVyW5CzgfuDVze5XAycDO4FvMxi9LUnq0bCA+GHgJcAm4H1JrgN+IMmKZvK+oapq0yybTmjZt4CzR6hXkjQmw55iehi4BrgmyZOBlwGHAF9Ocm1V/eKYapQk9WDOuZgAquo7wOXA5UmeAryy06okSb2bNSCSvHmchUiSJsuwx1yfMuPza/ut/1D3pUmS+jTsHsTv7FtO8vKZ65KkpW/UkdQjP94qSVoaOpvuW5K0uA27SX0rj/YcfizJjn2bGAxdeE7XxUmS+jPsMdeXja0KSdLEGRYQH6qql4ytEknSRBl2D8KpUiVpGRvWg3hakllHTFfVFR3UI0maEEMDgsF9iNle5mNASNISNiwgvlRVrxtbJZKkiTLsHkRbz0GStEwMC4jTx1aFJGnizBoQVXXbOAuRJE0Wp9qQJLWaNSCSXNv8+q7xlSNJmhTDnmJaneSFwClJLmW/m9ZV9bn5HjTJm4B/xeBx2VuBM4HVwKXAYcDngNOr6nvzPYYk6cAMC4i3AecBa4H37LetgBfP54BJ1gBvBI6uqr9PchlwGnAy8N6qujTJB4GzgAvmcwxJ0oEb9sKgfe+g/vdV9fYOjvsDSb4PHALsZhA4v9hs3wr8NgaEJPVmWA8CgKp6e5JTgBc0TddX1cfne8Cq+nKS/wTcD/w98GfATcDfVtXeZrddwJr5HkOSdODmfIopye8B5wB3NJ9zmrZ5SXIocCqwHvgR4AeBk1p2bX2LXZLNSbYn2T49PT3fMiRJc5izBwG8FPjHVfUIQJKtwM3AW+d5zJ8D7q2q6ebnXQH8LLAyyYqmF7EWeLDty1W1BdgCMDU15atQJakjo46DWDlj+WkHeMz7geOSHJIkwAkMeibXAa9q9jkDuOoAjyNJOgCj9CB+D7g5yXUMHnV9AfPvPVBVNya5nMGjrHsZ9Ea2AH8KXJrkPzRtF833GJKkAzfKTepLklwP/AyDgDi3qr5yIAetqvOB8/drvgc49kB+riRp4YzSg6CqdgPbOq5FkjRBnItJktTKgJAktRoaEEmekMRpvyVpGRoaEM3Yh1uSHDWmeiRJE2KUm9SrgduT/BXwrX2NVXVKZ1VJkno3SkD8TudVSJImzijjID6Z5EeBDVX1v5McAhzUfWmSpD6NMlnfLwOXA/+5aVoDXNllUZKk/o3ymOvZwPOBhwCq6m7giC6LkiT1b5SA+O7MV38mWcEsU3FLkpaOUQLik0l+g8Eb4H4e+G/A/+i2LElS30YJiPOAaeBW4FeAq4Hf6rIoSVL/RnmK6ZHmJUE3Mri0dFdVeYlJkpa4OQMiyUuBDwJ/zWC67/VJfqWqrum6OElSf0YZKPdu4EVVtRMgybMYvNzHgJCkJWyUexB79oVD4x5gT0f1SJImxKw9iCSvbBZvT3I1cBmDexCvBj47htokST0adonpX8xY/irwwmZ5Gji0s4okSRNh1oCoqjO7OmiSlcCFwE8x6JW8DrgL+BNgHXAf8AtV9fWuapAkDTfKXEzrk7wnyRVJtu37HOBx3w/8z6r6CeC5wJ0MxltcW1UbgGubdUlST0Z5iulK4CIGo6cfOdADJnkq8ALglwCaaTy+l+RU4Phmt63A9cC5B3o8SdL8jBIQ36mqDyzgMZ/J4D7Gf0nyXOAm4BzgGVW1G6CqdidxQkBJ6tEoj7m+P8n5SZ6XZOO+zwEccwWwEbigqo5h8Ja6kS8nJdmcZHuS7dPT0wdQhiRpmFF6ED8NnA68mEcvMVWzPh+7gF1VdWOzfjmDgPhqktVN72E1s4y1qKotwBaAqakpp/yQpI6MEhCvAJ45c8rvA1FVX0nyQJJnV9VdwAnAHc3nDOCdza9XLcTxJEnzM0pA3AKsZGFHT78B+GiSgxmMzD6TweWuy5KcBdzPYECeJKknowTEM4AvJPks8N19jVV1ynwPWlWfB6ZaNp0w358pSVpYowTE+Z1XIUmaOKO8D+KT4yhEkjRZRnkfxDd59B3UBwNPBL5VVU/tsjBJUr9G6UE8ZeZ6kpcDx3ZWkSRpIowyUO4xqupK5j8GQpK0SIxyiemVM1afwODpIweoSdISN8pTTDPfC7GXwVTcp3ZSjSRpYoxyD6Kz90JIkibXsFeOvm3I96qq3t5BPZKkCTGsB/GtlrYfBM4Cng4YEJK0hA175ei79y0neQqDdzacCVwKvHu270mSloah9yCSHAa8GXgNg7e8bfQ90ZK0PAy7B/H7wCsZvHvhp6vq78ZWlSSpd8MGyr0F+BHgt4AHkzzUfL6Z5KHxlCdJ6suwexCPe5S1JGnpMAQkSa0MCElSKwNCktTKgJAkteotIJIclOTmJB9v1tcnuTHJ3Un+JMnBfdUmSeq3B3EOcOeM9XcB762qDcDXGUzpIUnqSS8BkWQt8FLgwmY9DF5CdHmzy1bg5X3UJkka6KsH8T7g14FHmvWnA39bVXub9V3Amj4KkyQNjD0gkrwM2FNVN81sbtm19a11STYn2Z5k+/T0dCc1SpL66UE8HzglyX0MZoZ9MYMexcok+0Z2rwUebPtyVW2pqqmqmlq1atU46pWkZWnsAVFVb62qtVW1DjgN+POqeg1wHfCqZrczgKvGXZsk6VGTNA7iXODNSXYyuCdxUc/1SNKyNuc7qbtUVdcD1zfL9wDH9lmPJOlRk9SDkCRNEANCktTKgJAktTIgJEmtDAhJUisDQpLUyoCQJLUyICRJrQwISVIrA0KS1MqAkCS1MiAkSa0MCElSKwNCktTKgJAktTIgJEmtDAhJUisDQpLUyoCQJLUae0AkOTLJdUnuTHJ7knOa9sOSfCLJ3c2vh467NknSo/roQewF3lJVPwkcB5yd5GjgPODaqtoAXNusS5J6MvaAqKrdVfW5ZvmbwJ3AGuBUYGuz21bg5eOuTZL0qF7vQSRZBxwD3Ag8o6p2wyBEgCP6q0yS1FtAJPkh4GPAv62qhx7H9zYn2Z5k+/T0dHcFStIy10tAJHkig3D4aFVd0TR/NcnqZvtqYE/bd6tqS1VNVdXUqlWrxlOwJC1DfTzFFOAi4M6qes+MTduAM5rlM4Crxl2bJOlRK3o45vOB04Fbk3y+afsN4J3AZUnOAu4HXt1DbZKkxtgDoqr+Asgsm08YZy2SpNk5klqS1MqAkCS1MiAkSa0MCElSKwNCktTKgJAktTIgJEmtDAhJUisDQpLUyoCQJLUyICRJrQwISVIrA0KS1MqAkCS1MiAkSa0MCElSKwNCktTKgJAktTIgJEmtJi4gkpyY5K4kO5Oc13c9krRcTVRAJDkI+APgJOBoYFOSo/utSpKWp4kKCOBYYGdV3VNV3wMuBU7tuSZJWpYmLSDWAA/MWN/VtEmSxmxF3wXsJy1t9Zgdks3A5mb175Lc1XlVC+9w4G/6LmLMPOcxybvGfcR/4H/jxeNHR9lp0gJiF3DkjPW1wIMzd6iqLcCWcRa10JJsr6qpvusYJ8956Vtu5wtL/5wn7RLTZ4ENSdYnORg4DdjWc02StCxNVA+iqvYm+VXgfwEHARdX1e09lyVJy9JEBQRAVV0NXN13HR1b1JfI5slzXvqW2/nCEj/nVNXce0mSlp1JuwchSZoQBkSHRpk2JMkvJLkjye1J/njcNS6kuc43yVFJrktyc5IdSU7uo86FlOTiJHuS3DbL9iT5QPN7siPJxnHXuNBGOOfXNOe6I8lnkjx33DUutLnOecZ+P5Pk4SSvGldtnaoqPx18GNxk/2vgmcDBwC3A0fvtswG4GTi0WT+i77o7Pt8twL9plo8G7uu77gU47xcAG4HbZtl+MnANgzE+xwE39l3zGM75Z2f8mT5pOZxzs89BwJ8zuIf6qr5rXoiPPYjujDJtyC8Df1BVXweoqj1jrnEhjXK+BTy1WX4a+41xWYyq6lPA14bscirwkRq4AViZZPV4quvGXOdcVZ/Z92cauIHBeKZFbYT/zgBvAD4GLOb/jx/DgOjOKNOG/Djw40k+neSGJCeOrbqFN8r5/jbwL5PsYvCvrDeMp7ReLffpY85i0INa0pKsAV4BfLDvWhaSAdGdOacNYfCY8QbgeGATcGGSlR3X1ZVRzncT8OGqWsvg0st/TbLU/wyO8vuyJCV5EYOAOLfvWsbgfcC5VfVw34UspIkbB7GEzDltSLPPDVX1feDeZl6pDQxGlC82o5zvWcCJAFX1l0mezGAumyXTJW8xyu/LkpPkOcCFwElV9X/7rmcMpoBLk8Dgz/TJSfZW1ZX9lnVglvq/3vo0yrQhVwIvAkhyOINLTveMtcqFM8r53g+cAJDkJ4EnA9NjrXL8tgGvbZ5mOg74RlXt7ruoLiU5CrgCOL2qvth3PeNQVeural1VrQMuB16/2MMB7EF0pmaZNiTJ7wLbq2pbs+0lSe4AHgb+3WL919aI5/sW4ENJ3sTgMssvVfP4x2KV5BIGlwgPb+6tnA88EaCqPsjgXsvJwE7g28CZ/VS6cEY457cBTwf+sPkX9d5a5BPajXDOS5IjqSVJrbzEJElqZUBIkloZEJKkVgaEJKmVASFJamVASPOQZF3bzJ5JfrWZubWasS372pfcDKda+gwIaWF9Gvg54Ev7td8LvLCqngO8nSX+JjItDQ6Uk+ZvRZKtwDHAF4HXVtXNAM0AsX9QVZ+ZsbokZjjV0mcPQpq/ZwNbml7BQ8DrR/zespjhVIufASHN3wNV9elm+Y+AfzbXF5bZDKda5LzEJM3f/vPUDJ23ZhnOcKpFzh6ENH9HJXles7wJ+IvZdlyOM5xq8TMgpPm7EzgjyQ7gMOCCJG9sZvtcC+xIcmGz78wZTj+fZHs/JUujczZXSVIrexCSpFYGhCSplQEhSWplQEiSWhkQkqRWBoQkqZUBIUlqZUBIklr9P/KWdaT65gNXAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca7617d68>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca75c1f60>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca77e2390>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca78ad518>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7faca78e8f28>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[C]#4[C--]: 15\n",
      "[CH2--]#4[C]: 15\n",
      "[CH-]#4[C]: 15\n",
      "[CH2-]#[CH]: 15\n",
      "[C+]#[CH2-]: 15\n",
      "[CH+]=[CH3-]: 15\n",
      "[CH2-]#[C+]: 15\n",
      "[CH2-]#[N]: 15\n",
      "[C+]#[NH-]: 15\n",
      "[CH+]=[NH2-]: 15\n",
      "[C+]#[O-]: 15\n",
      "[CH+]=[OH-]: 15\n",
      "[CH2-]#[P]: 15\n",
      "[C+]#[PH-]: 15\n",
      "[CH+]=[PH2-]: 15\n",
      "[C+]#[S-]: 15\n",
      "[CH+]=[SH-]: 15\n",
      "[NH--]#4[C]: 15\n",
      "[NH2--]#[CH]: 15\n",
      "[N-]#4[C]: 15\n",
      "[NH-]#[CH]: 15\n",
      "[NH2-]=[CH2]: 15\n",
      "[NH2]-[CH4-]: 15\n",
      "[N+]=[CH3-]: 15\n",
      "[NH-]#[C+]: 15\n",
      "[NH2-]=[CH+]: 15\n",
      "[NH2--]#[N]: 15\n",
      "[NH-]#[N]: 15\n",
      "[NH2-]=[NH]: 15\n",
      "[NH2]-[NH3-]: 15\n",
      "[N+]=[NH2-]: 15\n",
      "[NH2-]=[N+]: 15\n",
      "[NH2-]=[O]: 15\n",
      "[NH2]-[OH2-]: 15\n",
      "[N+]=[OH-]: 15\n",
      "[NH2--]#[P]: 15\n",
      "[NH-]#[P]: 15\n",
      "[NH2-]=[PH]: 15\n",
      "[NH2]-[PH3-]: 15\n",
      "[N+]=[PH2-]: 15\n",
      "[NH2-]=[P+]: 15\n",
      "[NH2-]=[S]: 15\n",
      "[NH2]-[SH2-]: 15\n",
      "[N+]=[SH-]: 15\n",
      "[O--]#4[C]: 15\n",
      "[OH--]#[CH]: 15\n",
      "[OH2--]=[CH2]: 15\n",
      "[OH2-]-[CH4-]: 15\n",
      "[O-]#[CH]: 15\n",
      "[OH-]=[CH2]: 15\n",
      "[OH]-[CH4-]: 15\n",
      "[O-]#[C+]: 15\n",
      "[OH-]=[CH+]: 15\n",
      "[OH--]#[N]: 15\n",
      "[OH2--]=[NH]: 15\n",
      "[OH2-]-[NH3-]: 15\n",
      "[O-]#[N]: 15\n",
      "[OH-]=[NH]: 15\n",
      "[OH]-[NH3-]: 15\n",
      "[OH-]=[N+]: 15\n",
      "[OH2--]=[O]: 15\n",
      "[OH2-]-[OH2-]: 15\n",
      "[OH-]=[O]: 15\n",
      "[OH]-[OH2-]: 15\n",
      "[OH--]#[P]: 15\n",
      "[OH2--]=[PH]: 15\n",
      "[OH2-]-[PH3-]: 15\n",
      "[O-]#[P]: 15\n",
      "[OH-]=[PH]: 15\n",
      "[OH]-[PH3-]: 15\n",
      "[OH-]=[P+]: 15\n",
      "[OH2--]=[S]: 15\n",
      "[OH2-]-[SH2-]: 15\n",
      "[OH-]=[S]: 15\n",
      "[OH]-[SH2-]: 15\n",
      "[PH--]#4[C]: 15\n",
      "[PH2--]#[CH]: 15\n",
      "[P-]#4[C]: 15\n",
      "[PH-]#[CH]: 15\n",
      "[PH2-]=[CH2]: 15\n",
      "[PH2]-[CH4-]: 15\n",
      "[P+]=[CH3-]: 15\n",
      "[PH-]#[C+]: 15\n",
      "[PH2-]=[CH+]: 15\n",
      "[PH2--]#[N]: 15\n",
      "[PH-]#[N]: 15\n",
      "[PH2-]=[NH]: 15\n",
      "[PH2]-[NH3-]: 15\n",
      "[P+]=[NH2-]: 15\n",
      "[PH2-]=[N+]: 15\n",
      "[PH2-]=[O]: 15\n",
      "[PH2]-[OH2-]: 15\n",
      "[P+]=[OH-]: 15\n",
      "[PH2--]#[P]: 15\n",
      "[PH-]#[P]: 15\n",
      "[PH2-]=[PH]: 15\n",
      "[PH2]-[PH3-]: 15\n",
      "[P+]=[PH2-]: 15\n",
      "[PH2-]=[P+]: 15\n",
      "[PH2-]=[S]: 15\n",
      "[PH2]-[SH2-]: 15\n",
      "[P+]=[SH-]: 15\n",
      "[S--]#4[C]: 15\n",
      "[SH--]#[CH]: 15\n",
      "[SH2--]=[CH2]: 15\n",
      "[SH2-]-[CH4-]: 15\n",
      "[S-]#[CH]: 15\n",
      "[SH-]=[CH2]: 15\n",
      "[SH]-[CH4-]: 15\n",
      "[S-]#[C+]: 15\n",
      "[SH-]=[CH+]: 15\n",
      "[SH--]#[N]: 15\n",
      "[SH2--]=[NH]: 15\n",
      "[SH2-]-[NH3-]: 15\n",
      "[S-]#[N]: 15\n",
      "[SH-]=[NH]: 15\n",
      "[SH]-[NH3-]: 15\n",
      "[SH-]=[N+]: 15\n",
      "[SH2--]=[O]: 15\n",
      "[SH2-]-[OH2-]: 15\n",
      "[SH-]=[O]: 15\n",
      "[SH]-[OH2-]: 15\n",
      "[SH--]#[P]: 15\n",
      "[SH2--]=[PH]: 15\n",
      "[SH2-]-[PH3-]: 15\n",
      "[S-]#[P]: 15\n",
      "[SH-]=[PH]: 15\n",
      "[SH]-[PH3-]: 15\n",
      "[SH-]=[P+]: 15\n",
      "[SH2--]=[S]: 15\n",
      "[SH2-]-[SH2-]: 15\n",
      "[SH-]=[S]: 15\n",
      "[SH]-[SH2-]: 15\n",
      "[CH-]#4[CH-]: 14\n",
      "[CH2-]#[CH2-]: 14\n",
      "[C]#4[CH-]: 14\n",
      "[CH]#[CH2-]: 14\n",
      "[CH2]=[CH3-]: 14\n",
      "[CH3]-[CH3]: 14\n",
      "[CH2+]-[CH3]: 14\n",
      "[CH-]#4[N-]: 14\n",
      "[CH2-]#[NH-]: 14\n",
      "[C]#4[N-]: 14\n",
      "[CH]#[NH-]: 14\n",
      "[CH2]=[NH2-]: 14\n",
      "[CH3]-[NH2]: 14\n",
      "[CH2+]-[NH2]: 14\n",
      "[CH2-]#[O-]: 14\n",
      "[CH]#[O-]: 14\n",
      "[CH2]=[OH-]: 14\n",
      "[CH3]-[OH]: 14\n",
      "[CH2+]-[OH]: 14\n",
      "[CH-]#4[P-]: 14\n",
      "[CH2-]#[PH-]: 14\n",
      "[C]#4[P-]: 14\n",
      "[CH]#[PH-]: 14\n",
      "[CH2]=[PH2-]: 14\n",
      "[CH3]-[PH2]: 14\n",
      "[CH2+]-[PH2]: 14\n",
      "[CH2-]#[S-]: 14\n",
      "[CH]#[S-]: 14\n",
      "[CH2]=[SH-]: 14\n",
      "[CH3]-[SH]: 14\n",
      "[CH2+]-[SH]: 14\n",
      "[N-]#4[CH-]: 14\n",
      "[NH-]#[CH2-]: 14\n",
      "[NH2-]=[CH3-]: 14\n",
      "[N]#[CH2-]: 14\n",
      "[NH]=[CH3-]: 14\n",
      "[NH+]-[CH3]: 14\n",
      "[N-]#4[N-]: 14\n",
      "[NH-]#[NH-]: 14\n",
      "[NH2-]=[NH2-]: 14\n",
      "[NH2]-[NH4--]: 14\n",
      "[N]#[NH-]: 14\n",
      "[NH]=[NH2-]: 14\n",
      "[NH+]-[NH2]: 14\n",
      "[NH-]#[O-]: 14\n",
      "[NH2-]=[OH-]: 14\n",
      "[NH2]-[OH3--]: 14\n",
      "[N]#[O-]: 14\n",
      "[NH]=[OH-]: 14\n",
      "[NH+]-[OH]: 14\n",
      "[N-]#4[P-]: 14\n",
      "[NH-]#[PH-]: 14\n",
      "[NH2-]=[PH2-]: 14\n",
      "[NH2]-[PH4--]: 14\n",
      "[N]#[PH-]: 14\n",
      "[NH]=[PH2-]: 14\n",
      "[NH+]-[PH2]: 14\n",
      "[NH-]#[S-]: 14\n",
      "[NH2-]=[SH-]: 14\n",
      "[NH2]-[SH3--]: 14\n",
      "[N]#[S-]: 14\n",
      "[NH]=[SH-]: 14\n",
      "[NH+]-[SH]: 14\n",
      "[O-]#[CH2-]: 14\n",
      "[OH-]=[CH3-]: 14\n",
      "[O]=[CH3-]: 14\n",
      "[O+]-[CH3]: 14\n",
      "[O-]#[NH-]: 14\n",
      "[OH-]=[NH2-]: 14\n",
      "[OH]-[NH4--]: 14\n",
      "[O]=[NH2-]: 14\n",
      "[O+]-[NH2]: 14\n",
      "[O-]#[O-]: 14\n",
      "[OH-]=[OH-]: 14\n",
      "[OH]-[OH3--]: 14\n",
      "[O]=[OH-]: 14\n",
      "[O+]-[OH]: 14\n",
      "[O-]#[PH-]: 14\n",
      "[OH-]=[PH2-]: 14\n",
      "[OH]-[PH4--]: 14\n",
      "[O]=[PH2-]: 14\n",
      "[O+]-[PH2]: 14\n",
      "[O-]#[S-]: 14\n",
      "[OH-]=[SH-]: 14\n",
      "[OH]-[SH3--]: 14\n",
      "[O]=[SH-]: 14\n",
      "[O+]-[SH]: 14\n",
      "[P-]#4[CH-]: 14\n",
      "[PH-]#[CH2-]: 14\n",
      "[PH2-]=[CH3-]: 14\n",
      "[P]#[CH2-]: 14\n",
      "[PH]=[CH3-]: 14\n",
      "[PH+]-[CH3]: 14\n",
      "[P-]#4[N-]: 14\n",
      "[PH-]#[NH-]: 14\n",
      "[PH2-]=[NH2-]: 14\n",
      "[PH2]-[NH4--]: 14\n",
      "[P]#[NH-]: 14\n",
      "[PH]=[NH2-]: 14\n",
      "[PH+]-[NH2]: 14\n",
      "[PH-]#[O-]: 14\n",
      "[PH2-]=[OH-]: 14\n",
      "[PH2]-[OH3--]: 14\n",
      "[P]#[O-]: 14\n",
      "[PH]=[OH-]: 14\n",
      "[PH+]-[OH]: 14\n",
      "[P-]#4[P-]: 14\n",
      "[PH-]#[PH-]: 14\n",
      "[PH2-]=[PH2-]: 14\n",
      "[PH2]-[PH4--]: 14\n",
      "[P]#[PH-]: 14\n",
      "[PH]=[PH2-]: 14\n",
      "[PH+]-[PH2]: 14\n",
      "[PH-]#[S-]: 14\n",
      "[PH2-]=[SH-]: 14\n",
      "[PH2]-[SH3--]: 14\n",
      "[P]#[S-]: 14\n",
      "[PH]=[SH-]: 14\n",
      "[PH+]-[SH]: 14\n",
      "[S-]#[CH2-]: 14\n",
      "[SH-]=[CH3-]: 14\n",
      "[S]=[CH3-]: 14\n",
      "[S+]-[CH3]: 14\n",
      "[S-]#[NH-]: 14\n",
      "[SH-]=[NH2-]: 14\n",
      "[SH]-[NH4--]: 14\n",
      "[S]=[NH2-]: 14\n",
      "[S+]-[NH2]: 14\n",
      "[S-]#[O-]: 14\n",
      "[SH-]=[OH-]: 14\n",
      "[SH]-[OH3--]: 14\n",
      "[S]=[OH-]: 14\n",
      "[S+]-[OH]: 14\n",
      "[S-]#[PH-]: 14\n",
      "[SH-]=[PH2-]: 14\n",
      "[SH]-[PH4--]: 14\n",
      "[S]=[PH2-]: 14\n",
      "[S+]-[PH2]: 14\n",
      "[S-]#[S-]: 14\n",
      "[SH-]=[SH-]: 14\n",
      "[SH]-[SH3--]: 14\n",
      "[S]=[SH-]: 14\n",
      "[S+]-[SH]: 14\n"
     ]
    }
   ],
   "source": [
    "# enumeration of all homo-bidentates\n",
    "usual = list()\n",
    "dictBident = dict()\n",
    "scoredDictBident = dict()\n",
    "wishedDictBident = dict()\n",
    "\n",
    "for elem1 in elemList.keys():\n",
    "    for elem2 in elemList.keys():\n",
    "        for charge1 in range(-4, 5):\n",
    "            for h1 in hList:\n",
    "                for h2 in hList:\n",
    "#                      if h1 ==2 and h2 ==2 and elem1 == \"N\" and elem2 == \"C\":\n",
    "                        l1 = ligand(elem1, 0, 0)\n",
    "                        l1.setCharge(charge1)\n",
    "                        l1.setH(h1)\n",
    "                        l2 = ligand(elem2, 0, 0)\n",
    "                        l2.setCharge(0)\n",
    "                        l2.setH(h2)\n",
    "                        bestBondOrder1, bestBondOrder2, bestCharges, bondScore = fixCharge_bident([l1, l2])\n",
    "#                         print(bestBondOrder1)\n",
    "                        l1.setCharge(bestCharges[0])\n",
    "                        l2.setCharge(bestCharges[1])\n",
    "                        l1.getSmiles()\n",
    "                        l2.getSmiles()\n",
    "                        diatomName = ''.join(\n",
    "                            l1.SMILES + boDict[bestBondOrder1] + l2.SMILES +\n",
    "                            boDict[bestBondOrder2] + l2.SMILES +\n",
    "                            boDict[bestBondOrder1] + l1.SMILES)\n",
    "                        \n",
    "                        dictBident[diatomName] = [\n",
    "                            l1.numE, l1.numValE, l1.numLP, l1.charge,\n",
    "                            l1.numberOfHs,\n",
    "                            l1.testOctetRule(),\n",
    "                            l1.testValenceShell(),\n",
    "                            l1.score(), l2.numE, l2.numValE, l2.numLP, l2.charge,\n",
    "                            l2.numberOfHs,\n",
    "                            bondScore,\n",
    "                            bestBondOrder1,\n",
    "                            bestBondOrder2,\n",
    "                            l2.testOctetRule(),\n",
    "                            l2.testValenceShell(),\n",
    "                            l2.score(),\n",
    "                            endict[elem1], \n",
    "                            endict[elem1]-endict[elem2]+l1.numberOfHs*(endict[elem1]-endict[\"H\"]),\n",
    "                            endict[elem1]*endict[elem2]+l1.numberOfHs*(endict[elem1]*endict[\"H\"])\n",
    "\n",
    "                        ]\n",
    "\n",
    "# Figure out how many usuals there are in the nonCAs: {-2,4}.\n",
    "histUsual = list()\n",
    "\n",
    "for name, props in dictBident.items():\n",
    "    charge1 = props[3]\n",
    "    charge2 = props[11]\n",
    "    charge = charge1 + charge2\n",
    "    numberOfHs1 = props[4]\n",
    "    numberOfHs2 = props[12]\n",
    "    numValE1 = props[1]\n",
    "    numValE2 = props[9]\n",
    "    numLP1 = props[2]\n",
    "    numLP2 = props[10]\n",
    "    bondScore = props[13]\n",
    "    bestBondOrder1 = props[14]\n",
    "    bestBondOrder2 = props[15]\n",
    "    if charge < 3 and charge >= -4 and bondScore == 1 and not(bestBondOrder1 >= 2 and bestBondOrder2 >= 2) and not(bestBondOrder1 == 3 or bestBondOrder2 == 3) :\n",
    "    # charge under 3 and above -4 (actually, they are all in [-2,0])\n",
    "    # No ##, =#, #=, ==\n",
    "    # No #-, -#\n",
    "        \n",
    "        # Bond score\n",
    "        if bestBondOrder1 == 1 and bestBondOrder2 == 1:\n",
    "            scoreBond = 3\n",
    "        elif bestBondOrder1 == 1 and bestBondOrder2 == 2:\n",
    "            scoreBond = 3\n",
    "        elif bestBondOrder1 == 2 and bestBondOrder2 == 1:\n",
    "            scoreBond = 0\n",
    "        \n",
    "        # fulfill octet\n",
    "        usual1 = numValE1 - 2 * numLP1 + charge1 - 2 * numberOfHs1\n",
    "        usual2 = numValE2 - 2 * numLP2 + charge2 - 2 * numberOfHs2 - bestBondOrder2\n",
    "        scoreVsepr = 5 - np.abs(usual1 - usual2)\n",
    "        \n",
    "       \n",
    "        # Charge score\n",
    "        if charge1 == 0 and charge2 == 0: #0\n",
    "            scoreChargeDiff = 5\n",
    "#             print('1')\n",
    "        elif (charge1 == 1 and charge2 == -1) or (charge1 == -1 and charge2 == 1): #0\n",
    "            scoreChargeDiff = 3\n",
    "#             print('2')\n",
    "        elif charge1 == -1 and charge2 == -1: #-2\n",
    "            scoreChargeDiff = 3\n",
    "#             print('3')\n",
    "        elif charge1 == -2 and charge2 == -2: #-4\n",
    "            scoreChargeDiff = 0\n",
    "#             print('4')\n",
    "        elif (charge1 == 0 and charge2 == -1) or (charge1 == -1 and charge2 == 0): #-1\n",
    "            scoreChargeDiff = 3\n",
    "#             print('5')\n",
    "        elif (charge1 == 2 and charge2 == -1) or (charge1 == -1 and charge2 == 2): #-1\n",
    "            scoreChargeDiff = 0\n",
    "#             print('6')\n",
    "        elif (charge1 == 0 and charge2 == -2) or (charge1 == -2 and charge2 == 0): #-2\n",
    "            scoreChargeDiff = 2\n",
    "#             print('7')\n",
    "        elif (charge1 == -1 and charge2 == -2) or (charge1 == -2 and charge2 == -1): #-3\n",
    "            scoreChargeDiff = 1\n",
    "#             print('8')\n",
    "        elif (charge1 == -2 and charge2 == 0) or (charge1 == 0 and charge2 == -2): #-2\n",
    "            scoreChargeDiff = 2\n",
    "#             print('9')\n",
    "    \n",
    "        # CA Sterics Score\n",
    "        if numberOfHs1 == 3 or numberOfHs2 == 3: # 'and' never happens\n",
    "            scoreCa = 0\n",
    "        else:\n",
    "            scoreCa = 3\n",
    "\n",
    "        #Total score\n",
    "        score = scoreChargeDiff + scoreCa + scoreBond + scoreVsepr\n",
    "\n",
    "        scoredDictBident[name] = props + [scoreChargeDiff] + [scoreCa] + [scoreBond] + [scoreVsepr] + [score]\n",
    "       \n",
    "    \n",
    "thresholdBi = 13 #13\n",
    "histScore = list()\n",
    "histCa = list()\n",
    "histCharge = list()\n",
    "histCharge1 = list()\n",
    "histCharge2 = list()\n",
    "histVE = list()\n",
    "histBond = list()\n",
    "histBondScore = list()\n",
    "histBond1 = list()\n",
    "histBond2 = list()\n",
    "\n",
    "print(\"The 1st [.] is always the CA and the 2nd [.] is the bridging atom:\\n\")\n",
    "print(\"Name, Score = Polarization (Charge Diff) + CA + Bond + VSEPR \")\n",
    "for name, props in scoredDictBident.items():\n",
    "    histScore.append(props[-1])\n",
    "#     histBond.append(props[-2])\n",
    "#     histCa.append(props[-3])\n",
    "#     histCharge.append(props[-4])\n",
    "#     histVE.append(2 * (props[1] + props[9]))\n",
    "#     histBondScore.append(props[13])\n",
    "\n",
    "    # Populate the wishedDictBident\n",
    "    if props[-1] > thresholdBi:\n",
    "        wishedDictBident[name] = props\n",
    "#         histScore.append(props[-1])\n",
    "        histBond.append(props[-2])\n",
    "        histCa.append(props[-3])\n",
    "        histCharge1.append(props[3])\n",
    "        histCharge2.append(props[11])\n",
    "        histCharge.append(props[3]+props[11])\n",
    "        histVE.append(2 * (props[1] + props[9]))\n",
    "        histBond1.append(props[14])\n",
    "        histBond2.append(props[15])\n",
    "\n",
    "    # Evaluate compounds from Spectrochemical Series\n",
    "    for i in range(0, len(classicBidentates)):\n",
    "        if name == classicBidentates[i]:\n",
    "            print(name + ': ' + str(props[-5]) + ' + ' + str(props[-4]) + \" + \" + str(props[-3]) +\n",
    "                  \" + \" + str(props[-2]) + ' = ' + str(props[-1]))\n",
    "            \n",
    "\n",
    "print('\\n======')\n",
    "print(\"All bidentates: \" + str(len(dictBident)))\n",
    "print(\"All scored bidentates: \" + str(len(scoredDictBident)))\n",
    "print(\"All wished for bidentates: \" + str(len(wishedDictBident)))\n",
    "print('======')\n",
    "\n",
    "plt.xlabel('Score')\n",
    "# plt.yscale('log', nonposy='clip')\n",
    "plt.title('Histogram of Scored Space for THALs')\n",
    "plt.hist(histScore)\n",
    "plt.axvline(thresholdBi, color='black', linestyle='dashed', linewidth=2)\n",
    "plt.savefig('thal_ss_hist.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist2d(histVE, histCharge, cmap = 'Greys')\n",
    "plt.xlabel('v')\n",
    "plt.ylabel('c')\n",
    "plt.savefig('thal_ss_score_vs_v_2d_hist.pdf', bbox_inches='tight')\n",
    "plt.colorbar()\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histBond1)\n",
    "plt.ylabel('Number of THALs')\n",
    "plt.xlabel('b12')\n",
    "plt.savefig('thal_ss_hist_b12.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histBond2)\n",
    "plt.ylabel('Number of THALs')\n",
    "plt.xlabel('b23')\n",
    "plt.savefig('thal_ss_hist_b23.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histCharge)\n",
    "plt.ylabel('Number of THALs')\n",
    "plt.xlabel('c')\n",
    "plt.savefig('thal_ss_hist_charge.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histCharge1)\n",
    "plt.ylabel('Number of THALs')\n",
    "plt.xlabel('c1')\n",
    "plt.savefig('thal_ss_hist_c1.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "plt.hist(histCharge2)\n",
    "plt.ylabel('Number of THALs')\n",
    "plt.xlabel('c2')\n",
    "plt.savefig('thal_ss_hist_c2.pdf', bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "for i in reversed(range(thresholdBi, 16)):\n",
    "    for name, props in wishedDictDi.items():\n",
    "        if props[-1] == i:\n",
    "            print(name, end=\": \")\n",
    "            print(props[-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "code_folding": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Monodentates: 405\n",
      "Number of Bidentates: 148\n",
      "\n"
     ]
    }
   ],
   "source": [
    "###### readout xHALs\n",
    "lengths = [len(wishedDictMo) + len(wishedDictDi), len(wishedDictBident)]\n",
    "np.set_printoptions(threshold=np.nan)\n",
    "\n",
    "propMatMonodentate = np.zeros((lengths[0],5)) # 5 properties: name, tot charge, tot VE, tot EN of CAs diff, tot EN of CAs prod\n",
    "\n",
    "propMatBidentate = np.zeros((lengths[1],5))\n",
    "\n",
    "finalMo = list()\n",
    "finalDi = list()\n",
    "finalMonodentate = list()\n",
    "finalBidentate = list()\n",
    "\n",
    "for i in range(thresholdMo, 20):\n",
    "    for name, props in wishedDictMo.items():\n",
    "        if props[-1] == i:\n",
    "            finalMo.append((name, props[3], props[1], props[8], props[9], props[10]))\n",
    "\n",
    "for i in range(thresholdDi, 20):\n",
    "    for name, props in wishedDictDi.items():\n",
    "        if props[-1] == i:\n",
    "            # name, charge1+charge2, VE1+VE2, EN of CA = , \\Delta \\chi\n",
    "            finalDi.append((name, props[3]+props[11], props[1]+props[9], props[17], props[18], props[19]))\n",
    "\n",
    "for i in range(thresholdBi, 20):\n",
    "    for name, props in wishedDictBident.items():\n",
    "        if props[-1] == i: # entry 6 is CA, -1 for zero based\n",
    "            finalBidentate.append((name, 2*(props[3]+props[11]), 2*(props[1]+props[9]), props[19], props[20], props[21], props[4]+2*props[12]+3))\n",
    "\n",
    "finalMonodentate = sorted(finalMo) + sorted(finalDi)\n",
    "finalBidentate = sorted(finalBidentate)\n",
    "\n",
    "finalSmiMonodentate = list()\n",
    "finalSmiBidentate = list()\n",
    "\n",
    "ind = 0\n",
    "print('', file=open(\"finalSmiMonodentate.txt\", \"w\"), end='')\n",
    "print('', file=open(\"indicesNeutralHomolepticMonodentates.txt\", \"w\"), end='')\n",
    "print('', file=open(\"indicesNeg6HomolepticMonodentates.txt\", \"w\"), end='')\n",
    "print('', file=open(\"indicesPos6HomolepticMonodentates.txt\", \"w\"), end='')\n",
    "\n",
    "for i in finalMonodentate: #405\n",
    "    print(re.sub('[\\',]',\"\",str(i[0])), file=open(\"finalSmiMonodentate.txt\", \"a\"), end='') \n",
    "    print(\" 0\", file=open(\"finalSmiMonodentate.txt\", \"a\"))\n",
    "    propMatMonodentate[ind,0] = i[1]\n",
    "    propMatMonodentate[ind,1] = i[2]\n",
    "    propMatMonodentate[ind,2] = i[3]\n",
    "    propMatMonodentate[ind,3] = i[4]\n",
    "    propMatMonodentate[ind,4] = i[5]\n",
    "    if i[1] == 0:\n",
    "        print(ind, file=open(\"indicesNeutralHomolepticMonodentates.txt\",'a'))\n",
    "    elif i[1] == -1:\n",
    "        print(ind, file=open(\"indicesNeg6HomolepticMonodentates.txt\",'a'))    \n",
    "    elif i[1] == 1:\n",
    "        print(ind, file=open(\"indicesPos6HomolepticMonodentates.txt\",'a'))   \n",
    "    ind += 1\n",
    "    \n",
    "print(propMatMonodentate, file=open(\"propMatMonodentate.txt\", \"w\"))\n",
    "spMonodentate = sparse.csr_matrix(np.matrix(propMatMonodentate))\n",
    "\n",
    "\n",
    "ind = 0\n",
    "print('', file=open(\"finalSmiBidentate.txt\", \"w\"), end='')\n",
    "print('', file=open(\"indicesNeutralHomolepticBidentates.txt\", \"w\"), end='')\n",
    "print('', file=open(\"indicesNeg6HomolepticBidentates.txt\", \"w\"), end='')\n",
    "print('', file=open(\"indicesPos6HomolepticBidentates.txt\", \"w\"), end='')\n",
    "for i in finalBidentate: # 148\n",
    "    finalSmiBidentate.append(i[0])\n",
    "    smiStr = re.sub('[\\',]',\"\",str(i[0]))\n",
    "    print(smiStr, file=open(\"finalSmiBidentate.txt\", \"a\"), end='')\n",
    "    print(\" 1\", file=open(\"finalSmiBidentate.txt\", \"a\"), end='')\n",
    "    print(\" \" + str(i[6]+1), file=open(\"finalSmiBidentate.txt\", \"a\"))\n",
    "    propMatBidentate[ind,0] = i[1]\n",
    "    propMatBidentate[ind,1] = i[2]\n",
    "    propMatBidentate[ind,2] = i[3]\n",
    "    propMatBidentate[ind,3] = i[4]\n",
    "    propMatBidentate[ind,4] = i[5]\n",
    "    # we only allow for complexes in [-6,6] of charge\n",
    "    if i[1] == 0:\n",
    "        print(ind, file=open(\"indicesNeutralHomolepticBidentates.txt\",'a'))\n",
    "    elif i[1] == -2:\n",
    "        print(ind, file=open(\"indicesNeg6HomolepticBidentates.txt\",'a'))    \n",
    "    elif i[1] == 2:\n",
    "        print(ind, file=open(\"indicesPos6HomolepticBidentates.txt\",'a'))   \n",
    "    ind += 1\n",
    "print(propMatBidentate, file=open(\"propMatBidentate.txt\", \"w\"))\n",
    "spBidentate = sparse.csr_matrix(np.matrix(propMatBidentate))\n",
    "    \n",
    "print('Number of Monodentates: ' + str(len(finalMonodentate)))\n",
    "print('Number of Bidentates: ' + str(len(finalBidentate)), end='\\n\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 253,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Homoleptic Bidentate Complexes: 148\n",
      "My Homoleptic Bidentates took 0.003468751907348633s to permute\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "###########################\n",
    "# BIDENTATES BELOW HERE #\n",
    "###########################\n",
    "\n",
    "# Generate Homoleptic Bidentates \n",
    "start_time = time.time()\n",
    "homolepBidentatesProj = sparse.diags(np.ones(lengths[1]) * 3)\n",
    "pickle.dump(homolepBidentatesProj, file=open(\"homolepBidentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of Homoleptic Bidentate Complexes: \" + str((homolepBidentatesProj.getnnz())))\n",
    "pickle.dump(homolepBidentatesProj * spBidentate, file=open(\"homolepBidentates.p\", \"wb\"))\n",
    "print(\"My Homoleptic Bidentates took \" + str(time.time() - start_time) + \"s to permute\")\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 257,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "2\n",
      "3\n",
      "4\n",
      "5\n",
      "6\n",
      "7\n",
      "8\n",
      "9\n",
      "10\n",
      "11\n",
      "12\n",
      "13\n",
      "14\n",
      "15\n",
      "16\n",
      "17\n",
      "18\n",
      "19\n",
      "20\n",
      "21\n",
      "22\n",
      "23\n",
      "24\n",
      "25\n",
      "26\n",
      "27\n",
      "28\n",
      "29\n",
      "30\n",
      "31\n",
      "32\n",
      "33\n",
      "34\n",
      "35\n",
      "36\n",
      "37\n",
      "38\n",
      "39\n",
      "40\n",
      "41\n",
      "42\n",
      "43\n",
      "44\n",
      "45\n",
      "46\n",
      "47\n",
      "48\n",
      "49\n",
      "50\n",
      "51\n",
      "52\n",
      "53\n",
      "54\n",
      "55\n",
      "56\n",
      "57\n",
      "58\n",
      "59\n",
      "60\n",
      "61\n",
      "62\n",
      "63\n",
      "64\n",
      "65\n",
      "66\n",
      "67\n",
      "68\n",
      "69\n",
      "70\n",
      "71\n",
      "72\n",
      "73\n",
      "74\n",
      "75\n",
      "76\n",
      "77\n",
      "78\n",
      "79\n",
      "80\n",
      "81\n",
      "82\n",
      "83\n",
      "84\n",
      "85\n",
      "86\n",
      "87\n",
      "88\n",
      "89\n",
      "90\n",
      "91\n",
      "92\n",
      "93\n",
      "94\n",
      "95\n",
      "96\n",
      "97\n",
      "98\n",
      "99\n",
      "100\n",
      "101\n",
      "102\n",
      "103\n",
      "104\n",
      "105\n",
      "106\n",
      "107\n",
      "108\n",
      "109\n",
      "110\n",
      "111\n",
      "112\n",
      "113\n",
      "114\n",
      "115\n",
      "116\n",
      "117\n",
      "118\n",
      "119\n",
      "120\n",
      "121\n",
      "122\n",
      "123\n",
      "124\n",
      "125\n",
      "126\n",
      "127\n",
      "128\n",
      "129\n",
      "130\n",
      "131\n",
      "132\n",
      "133\n",
      "134\n",
      "135\n",
      "136\n",
      "137\n",
      "138\n",
      "139\n",
      "140\n",
      "141\n",
      "142\n",
      "143\n",
      "144\n",
      "145\n",
      "146\n",
      "147\n"
     ]
    }
   ],
   "source": [
    "# Generate Weak Sym Matrix Bidentates <<<<<<<<<<<<<<<<<<<<<<<<<<<3\n",
    "\n",
    "start_time = time.time()\n",
    "# weaksymBidentatesProj  = np.zeros(lengths[0]+lengths[1])\n",
    "# weaksymBidentatesProjA = np.zeros(lengths[0]) # mono part lengths[0]\n",
    "# weaksymBidentatesProjB = np.zeros(lengths[1]) # bi part lengths[1]\n",
    "\n",
    "# weaksymBidentatesProjA[0] = 1\n",
    "# weaksymBidentatesProjA[1] = 1  # we have two mono- and one bidentate\n",
    "# weaksymBidentatesProjB[0] = 1 \n",
    "\n",
    "# weaksymBidentatesProjA = sparse.csr_matrix(np.array(list(mit.distinct_permutations(weaksymBidentatesProjA))))\n",
    "# weaksymBidentatesProjB = sparse.csr_matrix(np.array(list(mit.distinct_permutations(weaksymBidentatesProjB))))\n",
    "\n",
    "# flag = 1\n",
    "# for i in range(0,weaksymBidentatesProjB.getnnz()): # give 148 parts because we have bidentates in outer loop weaksymBidentatesProjB.getnnz()\n",
    "#     weaksymBidentatesProj  = np.zeros(lengths[0]+lengths[1])\n",
    "#     for j in range(0, int(weaksymBidentatesProjA.getnnz()/2)): #int(weaksymBidentatesProjA.getnnz()/2)\n",
    "#         if flag == 1:\n",
    "#             weaksymBidentatesProj = sparse.hstack([weaksymBidentatesProjA.getrow(j), weaksymBidentatesProjB.getrow(i)])\n",
    "#             flag = 0\n",
    "#         else: # to prevent the first entry from being just a zero thing\n",
    "#             weaksymBidentatesProj = sparse.vstack([weaksymBidentatesProj, sparse.hstack([weaksymBidentatesProjA.getrow(j), weaksymBidentatesProjB.getrow(i)])])\n",
    "            \n",
    "#     print(str(i) + ': ' + str(time.time() - start_time))\n",
    "#     pickle.dump(weaksymBidentatesProj, file=open(\"weaksymBidentatesProj/weaksymBidentatesProj_\" + str('{:03}'.format(i)) + \".p\", \"wb\"), protocol=2)  \n",
    "\n",
    "for k in range(0, weaksymBidentatesProjB.getnnz()): # this could be done in the loop above but we dont because we split it up \n",
    "    partial_weaksymBidentatesProj = pickle.load( open(\"weaksymBidentatesProj/weaksymBidentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"rb\" ) )\n",
    "    \n",
    "    pickle.dump(partial_weaksymBidentatesProj * sparse.vstack([spMonodentate, spBidentate]), file=open(\"weaksymBidentates/weaksymBidentates_\" + str('{:03}'.format(k)) + \".p\", \"wb\"))\n",
    "    print(k)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Strong Sym Bidentate Complexes: 21756.0\n",
      "My Strongly Symmetric Complexes took 1.852250576019287s to permute\n"
     ]
    }
   ],
   "source": [
    "# Generate Strong Sym BIDENTATES axially connected (ac)\n",
    "start_time = time.time()\n",
    "strongsymAcBidentatesProj = np.zeros(lengths[1])\n",
    "strongsymAcBidentatesProj[0] = 1\n",
    "strongsymAcBidentatesProj[1] = 2 # two bidentates give the 4 CA in the eq plane\n",
    "strongsymAcBidentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(strongsymAcBidentatesProj))))\n",
    "pickle.dump(strongsymAcBidentatesProj, file=open(\"strongsymAcBidentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of Strong Sym Bidentate Complexes: \" + str(strongsymAcBidentatesProj.getnnz()/2))\n",
    "pickle.dump(strongsymAcBidentatesProj * spBidentate, file=open(\"strongsymAcBidentates.p\", \"wb\"))\n",
    "print(\"My Strongly Symmetric Complexes took \" + str(time.time() - start_time) + \"s to permute\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Strong Sym ADC Bidentate Complexes: 59940.0\n",
      "My Strongly Symmetric Complexes took 66.2125780582428s to permute\n"
     ]
    }
   ],
   "source": [
    "# Generate Strong Sym BIDENTATES axially DISconnected (adc) MIXED bi/mono\n",
    "start_time = time.time()\n",
    "# strongsymAdcBidentatesProj  = np.zeros(lengths[0]+lengths[1])\n",
    "strongsymAdcBidentatesProjA = np.zeros(lengths[0]) # mono part lengths[0]\n",
    "strongsymAdcBidentatesProjB = np.zeros(lengths[1]) # bi part lengths[1]\n",
    "\n",
    "strongsymAdcBidentatesProjA[0] = 1\n",
    "strongsymAdcBidentatesProjB[0] = 1 \n",
    "\n",
    "strongsymAdcBidentatesProjA = sparse.csr_matrix(np.array(list(mit.distinct_permutations(strongsymAdcBidentatesProjA))))\n",
    "strongsymAdcBidentatesProjB = sparse.csr_matrix(np.array(list(mit.distinct_permutations(strongsymAdcBidentatesProjB))))\n",
    "\n",
    "flag = 1\n",
    "for i in range(0, strongsymAdcBidentatesProjA.getnnz()):\n",
    "    for j in range(0, strongsymAdcBidentatesProjB.getnnz()):\n",
    "        if flag == 1:\n",
    "            strongsymAdcBidentatesProj = sparse.hstack([strongsymAdcBidentatesProjA.getrow(i), strongsymAdcBidentatesProjB.getrow(j)])\n",
    "            flag = 0\n",
    "        else: # to prevent the first entry from being just a zero thing\n",
    "            strongsymAdcBidentatesProj = sparse.vstack([strongsymAdcBidentatesProj, sparse.hstack([strongsymAdcBidentatesProjA.getrow(i), strongsymAdcBidentatesProjB.getrow(j)])])\n",
    "\n",
    "            # strongsymAdcBidentatesProj = np.delete(strongsymAdcBidentatesProj, 0, axis=0)  # remove initialize zeros row       \n",
    "\n",
    "pickle.dump(strongsymAdcBidentatesProj, file=open(\"strongsymAdcBidentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of Strong Sym ADC Bidentate Complexes: \" + str(strongsymAdcBidentatesProj.getnnz()/2))\n",
    "pickle.dump(strongsymAdcBidentatesProj * sparse.vstack([spMonodentate, spBidentate]), file=open(\"strongsymAdcBidentates.p\", \"wb\"))\n",
    "print(\"My Strongly Symmetric Complexes took \" + str(time.time() - start_time) + \"s to permute\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "My eqasym AC bident Complexes took 0.8421716690063477 s to permute\n",
      "0: 7.122774362564087 s\n",
      "1: 13.173807382583618 s\n",
      "2: 19.203762531280518 s\n",
      "3: 25.411353826522827 s\n",
      "4: 31.42447566986084 s\n",
      "5: 37.43806266784668 s\n",
      "6: 43.44443225860596 s\n",
      "7: 49.486178159713745 s\n",
      "8: 55.473628520965576 s\n",
      "9: 61.57978129386902 s\n",
      "10: 67.59516954421997 s\n",
      "11: 73.5907084941864 s\n",
      "12: 79.59305882453918 s\n",
      "13: 85.628826379776 s\n",
      "14: 91.66091227531433 s\n",
      "15: 97.77088832855225 s\n",
      "16: 103.8112154006958 s\n",
      "17: 109.84823846817017 s\n",
      "18: 115.86808586120605 s\n",
      "19: 121.86237287521362 s\n",
      "20: 127.85613679885864 s\n",
      "21: 133.82772755622864 s\n",
      "22: 139.81771969795227 s\n",
      "23: 145.8371798992157 s\n",
      "24: 151.8580915927887 s\n",
      "25: 157.9175317287445 s\n",
      "26: 163.9079234600067 s\n",
      "27: 169.87124037742615 s\n",
      "28: 175.8433177471161 s\n",
      "29: 181.8881471157074 s\n",
      "30: 187.9151473045349 s\n",
      "31: 193.88655352592468 s\n",
      "32: 199.8654260635376 s\n",
      "33: 205.88301873207092 s\n",
      "34: 211.94216918945312 s\n",
      "35: 217.965411901474 s\n",
      "36: 223.9680449962616 s\n",
      "37: 229.99028134346008 s\n",
      "38: 236.03992700576782 s\n",
      "39: 242.0810272693634 s\n",
      "40: 248.13621068000793 s\n",
      "41: 254.17134356498718 s\n",
      "42: 260.1730127334595 s\n",
      "43: 266.1757414340973 s\n",
      "44: 272.2144048213959 s\n",
      "45: 278.22347354888916 s\n",
      "46: 284.2442944049835 s\n",
      "47: 290.2972037792206 s\n",
      "48: 296.36511611938477 s\n",
      "49: 302.37479972839355 s\n",
      "50: 308.39276218414307 s\n",
      "51: 314.39364528656006 s\n",
      "52: 320.39734506607056 s\n",
      "53: 326.43621706962585 s\n",
      "54: 332.4602506160736 s\n",
      "55: 338.4615521430969 s\n",
      "56: 344.4394750595093 s\n",
      "57: 350.4052436351776 s\n",
      "58: 356.4030876159668 s\n",
      "59: 362.4079809188843 s\n",
      "60: 368.4308776855469 s\n",
      "61: 374.44348645210266 s\n",
      "62: 380.5171113014221 s\n",
      "63: 386.6161777973175 s\n",
      "64: 392.6608819961548 s\n",
      "65: 398.74088644981384 s\n",
      "66: 404.9680280685425 s\n",
      "67: 410.9525227546692 s\n",
      "68: 416.9542508125305 s\n",
      "69: 422.99206376075745 s\n",
      "70: 429.22472858428955 s\n",
      "71: 435.2365825176239 s\n",
      "72: 441.25739765167236 s\n",
      "73: 447.32568073272705 s\n",
      "74: 453.36287355422974 s\n",
      "75: 459.3902499675751 s\n",
      "76: 465.407678604126 s\n",
      "77: 471.42050790786743 s\n",
      "78: 477.44156312942505 s\n",
      "79: 483.463259935379 s\n",
      "80: 489.4558608531952 s\n",
      "81: 495.43144178390503 s\n",
      "82: 501.4269280433655 s\n",
      "83: 507.41551995277405 s\n",
      "84: 513.4483823776245 s\n",
      "85: 519.4748778343201 s\n",
      "86: 525.4977893829346 s\n",
      "87: 531.5510065555573 s\n",
      "88: 537.6025500297546 s\n",
      "89: 543.6017422676086 s\n",
      "90: 549.5986144542694 s\n",
      "91: 555.5629432201385 s\n",
      "92: 561.5668320655823 s\n",
      "93: 567.5731852054596 s\n",
      "94: 573.5507040023804 s\n",
      "95: 579.5449969768524 s\n",
      "96: 585.5636909008026 s\n",
      "97: 591.5872542858124 s\n",
      "98: 597.6138896942139 s\n",
      "99: 603.6170752048492 s\n",
      "100: 609.6471698284149 s\n",
      "101: 615.6576845645905 s\n",
      "102: 621.6667838096619 s\n",
      "103: 627.6442716121674 s\n",
      "104: 633.6497147083282 s\n",
      "105: 639.6903648376465 s\n",
      "106: 645.6984124183655 s\n",
      "107: 651.706531047821 s\n",
      "108: 657.75293135643 s\n",
      "109: 663.8002195358276 s\n",
      "110: 669.8151800632477 s\n",
      "111: 675.820583820343 s\n",
      "112: 681.7783651351929 s\n",
      "113: 687.7585134506226 s\n",
      "114: 693.706866979599 s\n",
      "115: 699.6764516830444 s\n",
      "116: 705.6527628898621 s\n",
      "117: 711.6096374988556 s\n",
      "118: 717.6228141784668 s\n",
      "119: 723.6380724906921 s\n",
      "120: 729.6290493011475 s\n",
      "121: 735.6312243938446 s\n",
      "122: 741.6090252399445 s\n",
      "123: 747.6114859580994 s\n",
      "124: 753.6023817062378 s\n",
      "125: 759.611260175705 s\n",
      "126: 765.6120421886444 s\n",
      "127: 771.5859339237213 s\n",
      "128: 777.5664391517639 s\n",
      "129: 783.5333511829376 s\n",
      "130: 789.5851607322693 s\n",
      "131: 795.6100473403931 s\n",
      "132: 801.5902278423309 s\n",
      "133: 807.5541863441467 s\n",
      "134: 813.5398690700531 s\n",
      "135: 819.5190994739532 s\n",
      "136: 825.4812934398651 s\n",
      "137: 831.4596002101898 s\n",
      "138: 837.4329693317413 s\n",
      "139: 843.4393258094788 s\n",
      "140: 849.4992635250092 s\n",
      "141: 855.5222551822662 s\n",
      "142: 861.523467540741 s\n",
      "143: 867.4896140098572 s\n",
      "144: 873.4781918525696 s\n",
      "145: 879.6959328651428 s\n",
      "146: 885.6929416656494 s\n",
      "147: 891.7618110179901 s\n",
      "148\n"
     ]
    }
   ],
   "source": [
    "# Generate equatorially asym BIDENTATES axially connected (ac) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< FRI MAY 4: change to generate two matrices to distinguish 1 and 1'=2\n",
    "start_time = time.time()\n",
    "eqasymAcBidentatesProj = np.zeros(lengths[1] - 1) # minus 1 because we took out '4' and introduce it later by instertion to split up the calculation\n",
    "eqasymAcBidentatesProj[0] = 1\n",
    "eqasymAcBidentatesProj[1] = 1\n",
    "eqasymAcBidentatesProjBlock = np.array(list(mit.distinct_permutations(eqasymAcBidentatesProj)))\n",
    "print(\"My eqasym AC bident Complexes took \" + str(time.time() - start_time) + \" s to permute\")\n",
    "\n",
    "for k in range(0, np.shape(eqasymAcBidentatesProjBlock)[1] + 1): # plus 1 because we also want an insertion after the last item: np.shape(eqasymAcBidentatesProjBlock)[1] + 1\n",
    "    #this will have a 0-line as a first line in every block\n",
    "    eqasymAcBidentatesProj = sparse.csr_matrix(np.zeros(np.shape(eqasymAcBidentatesProjBlock)[1] + 1)) # plus 1 because we also want an insertion after the last item\n",
    "    eqasymAcBidentatesProjForRacsDistinguishable = sparse.csr_matrix(np.zeros(np.shape(eqasymAcBidentatesProjBlock)[1] + 1))\n",
    "    for i in eqasymAcBidentatesProjBlock:\n",
    "        eqasymAcBidentatesProj = sparse.vstack([eqasymAcBidentatesProj, sparse.csr_matrix(np.insert(i, k, 1))])\n",
    "        eqasymAcBidentatesProjForRacsDistinguishable = sparse.vstack([eqasymAcBidentatesProjForRacsDistinguishable, sparse.csr_matrix(np.insert(i, k, 2))])\n",
    "    pickle.dump(eqasymAcBidentatesProj, file=open(\"eqasymAcBidentatesProj/eqasymAcBidentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"wb\"), protocol = 2)\n",
    "    pickle.dump(eqasymAcBidentatesProjForRacsDistinguishable, file=open(\"eqasymAcBidentatesProj/eqasymAcBidentatesProjForRacsDistinguishable_\" + str('{:03}'.format(k)) + \".p\", \"wb\"), protocol = 2)\n",
    "    print(str(k) + ': ' + str((time.time() - start_time)) + ' s')\n",
    "\n",
    "print(np.shape(eqasymAcBidentatesProjBlock)[1] + 1)   \n",
    "for k in range(0, np.shape(eqasymAcBidentatesProjBlock)[1] + 1): # this could be done in the loop above but we dont because we split it up np.shape(eqasymAcBidentatesProjBlock)[1] + 1\n",
    "    partial_eqasymAcBidentatesProj = pickle.load( open(\"eqasymAcBidentatesProj/eqasymAcBidentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"rb\" ) )\n",
    "    pickle.dump(partial_eqasymAcBidentatesProj * spBidentate, file=open(\"eqasymAcBidentates/eqasymAcBidentates_\" + str('{:03}'.format(k)) + \".p\", \"wb\"), protocol = 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 330,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 "
     ]
    }
   ],
   "source": [
    "# Generate equatorially asym BIDENTATES axially disconnected (adc) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< FRI 27 APRIL start DONE\n",
    "start_time = time.time()\n",
    "## eqasymAdcBidentatesProj  = np.zeros(lengths[0]+lengths[1])\n",
    "# eqasymAdcBidentatesProjA = np.zeros(lengths[0]) # mono part lengths[0]\n",
    "# eqasymAdcBidentatesProjB = np.zeros(lengths[1]) # bi part lengths[1]\n",
    "\n",
    "# eqasymAdcBidentatesProjA[0] = 1\n",
    "# eqasymAdcBidentatesProjB[0] = 1\n",
    "# eqasymAdcBidentatesProjB[1] = 1\n",
    "\n",
    "# eqasymAdcBidentatesProjA = sparse.csr_matrix(np.array(list(mit.distinct_permutations(eqasymAdcBidentatesProjA))))\n",
    "# eqasymAdcBidentatesProjB = sparse.csr_matrix(np.array(list(mit.distinct_permutations(eqasymAdcBidentatesProjB))))\n",
    "\n",
    "# print('Took so much to generate perms: ' + str(time.time() - start_time))\n",
    "\n",
    "# flag = 1\n",
    "# for i in range(0, eqasymAdcBidentatesProjA.getnnz()): # eqasymAdcBidentatesProjA.getnnz()\n",
    "#     eqasymAdcBidentatesProj = sparse.csr_matrix(np.zeros(lengths[0]+lengths[1]))\n",
    "#     for j in range(0, int(eqasymAdcBidentatesProjB.getnnz()/2)):\n",
    "#         if flag == 1:\n",
    "#             eqasymAdcBidentatesProj = sparse.hstack([eqasymAdcBidentatesProjA.getrow(i), eqasymAdcBidentatesProjB.getrow(j)])\n",
    "#             flag = 0\n",
    "#         else: # to prevent the first entry from being just a zero thing\n",
    "#             eqasymAdcBidentatesProj = sparse.vstack([eqasymAdcBidentatesProj, sparse.hstack([eqasymAdcBidentatesProjA.getrow(i), eqasymAdcBidentatesProjB.getrow(j)])])\n",
    "\n",
    "#     print(str(i) + ': ' + str((time.time() - start_time)/60) + ' min')\n",
    "#     pickle.dump(eqasymAdcBidentatesProj, file=open(\"eqasymAdcBidentatesProj/eqasymAdcBidentatesProj_\" + str('{:03}'.format(i)) + \".p\", \"wb\"), protocol=2)  \n",
    "    \n",
    "for k in range(0, eqasymAdcBidentatesProjA.getnnz()): # this could be done in the loop above but we dont because we split it up \n",
    "    partial_eqasymAdcBidentatesProj = pickle.load( open(\"eqasymAdcBidentatesProj/eqasymAdcBidentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"rb\" ) )\n",
    "    pickle.dump(partial_eqasymAdcBidentatesProj * sparse.vstack([spMonodentate, spBidentate]), file=open(\"eqasymAdcBidentates/eqasymAdcBidentates_\" + str('{:03}'.format(k)) + \".p\", \"wb\"))\n",
    "    print(k, end=' ')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Strong Sym Bidentate Complexes: 21756.0\n",
      "My Strongly Symmetric Complexes took 1.836488962173462s to permute\n"
     ]
    }
   ],
   "source": [
    "# Generate 4+2 BIDENTATES \n",
    "start_time = time.time()\n",
    "fourtwosymBidentatesProj = np.zeros(lengths[1])\n",
    "fourtwosymBidentatesProj[0] = 1\n",
    "fourtwosymBidentatesProj[1] = 2 # two bidentates give the 4 CA in the eq plane\n",
    "fourtwosymBidentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(fourtwosymBidentatesProj))))\n",
    "pickle.dump(fourtwosymBidentatesProj, file=open(\"fourtwosymBidentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of Strong Sym Bidentate Complexes: \" + str(fourtwosymBidentatesProj.getnnz()/2))\n",
    "pickle.dump(fourtwosymBidentatesProj * spBidentate, file=open(\"fourtwosymBidentates.p\", \"wb\"), protocol=2)\n",
    "print(\"My Strongly Symmetric Complexes took \" + str(time.time() - start_time) + \"s to permute\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 315,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Homoleptic Monodentate Complexes: 405\n",
      "My Homoleptics took 0.0035300254821777344s to permute\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "###########################\n",
    "# MONODENTATES BELOW HERE #\n",
    "###########################\n",
    "\n",
    "np.set_printoptions(threshold=np.nan)\n",
    "\n",
    "# Generate Homoleptic Matrix\n",
    "start_time = time.time()\n",
    "homolepMonodentatesProj = sparse.diags(np.ones(lengths[0]) * 6)\n",
    "pickle.dump(homolepMonodentatesProj, file=open(\"homolepMonodentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of Homoleptic Monodentate Complexes: \" + str((homolepMonodentatesProj.getnnz())))\n",
    "pickle.dump(homolepMonodentatesProj * spMonodentate, file=open(\"homolepMonodentates.p\", \"wb\"))\n",
    "print(\"My Homoleptics took \" + str(time.time() - start_time) + \"s to permute\")\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'weaksymMonodentatesProjBlock' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-23-a423941049fc>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     21\u001b[0m \u001b[0;31m# => we run these lines bellow, see all output files in enum/weaksymMonodentates. Took about 30 s.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 22\u001b[0;31m \u001b[0;32mfor\u001b[0m \u001b[0mk\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mweaksymMonodentatesProjBlock\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0;31m# this could be done in the loop above but we dont because we split it up np.shape(weaksymMonodentatesProjBlock)[1] + 1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     23\u001b[0m     \u001b[0mpartial_weaksymMonodentatesProj\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpickle\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"weaksymMonodentatesProj/weaksymMonodentatesProj_\"\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'{:03}'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mk\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m\".p\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"rb\"\u001b[0m \u001b[0;34m)\u001b[0m \u001b[0;34m,\u001b[0m \u001b[0mprotocol\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     24\u001b[0m     \u001b[0mpickle\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpartial_weaksymMonodentatesProj\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mspMonodentate\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfile\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"weaksymMonodentates/weaksymMonodentates_\"\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'{:03}'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mk\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m\".p\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"wb\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'weaksymMonodentatesProjBlock' is not defined"
     ]
    }
   ],
   "source": [
    "# Generate Weak Sym Matrix mono\n",
    "from sys import getsizeof\n",
    "start_time = time.time()\n",
    "weaksymMonodentatesProj = np.zeros(lengths[0] - 1) # minus 1 because we took out '4' and introduce it later by instertion to split up the calculation\n",
    "weaksymMonodentatesProj[0] = 1\n",
    "weaksymMonodentatesProj[1] = 1\n",
    "## weaksymMonodentatesProj[2] = 4\n",
    "## weaksymMonodentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(weaksymMonodentatesProj))))\n",
    "# weaksymMonodentatesProjBlock = np.array(list(mit.distinct_permutations(weaksymMonodentatesProj)))\n",
    "print(\"My Weakly Symmetric Complexes took \" + str(time.time() - start_time) + \"s to permute\")\n",
    "\n",
    "# # weaksymMonodentatesProjBlock is the permutation without the \"4\", we initialize a proj mat and store every 4-insertion into a *.p file.\n",
    "# # we didnt have the proj * props here yet (before we'd need a vstack of all the block-proj)\n",
    "# => we run these lines bellow, see all output files in enum/weaksymMonodentatesProj. Took about 6 h.\n",
    "# for k in range(1, np.shape(weaksymMonodentatesProjBlock)[1] + 1): # plus 1 because we also want an insertion after the last item: np.shape(weaksymMonodentatesProjBlock)[1] + 1\n",
    "#     weaksymMonodentatesProj = sparse.csr_matrix(np.zeros(np.shape(weaksymMonodentatesProjBlock)[1] + 1)) # plus 1 because we also want an insertion after the last item\n",
    "#     for i in weaksymMonodentatesProjBlock:\n",
    "#         weaksymMonodentatesProj = sparse.vstack([weaksymMonodentatesProj, sparse.csr_matrix(np.insert(i, k, 4))])\n",
    "#     pickle.dump(weaksymMonodentatesProj, file=open(\"weaksymMonodentatesProj/weaksymMonodentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"wb\"))\n",
    "\n",
    "# => we run these lines bellow, see all output files in enum/weaksymMonodentates. Took about 30 s.\n",
    "for k in range(0, np.shape(weaksymMonodentatesProjBlock)[1] + 1): # this could be done in the loop above but we dont because we split it up np.shape(weaksymMonodentatesProjBlock)[1] + 1\n",
    "    partial_weaksymMonodentatesProj = pickle.load( open(\"weaksymMonodentatesProj/weaksymMonodentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"rb\" ) )\n",
    "    pickle.dump(partial_weaksymMonodentatesProj * spMonodentate, file=open(\"weaksymMonodentates/weaksymMonodentates_\" + str('{:03}'.format(k)) + \".p\", \"wb\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 316,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Strong Sym Monodentate Complexes: 163620.0\n",
      "My Strongly Symmetric Complexes took 37.51969242095947s to permute\n"
     ]
    }
   ],
   "source": [
    "# Generate Strong Sym Matrix\n",
    "start_time = time.time()\n",
    "strongsymMonodentatesProj = np.zeros(lengths[0])\n",
    "strongsymMonodentatesProj[0] = 2\n",
    "strongsymMonodentatesProj[1] = 4\n",
    "strongsymMonodentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(strongsymMonodentatesProj))))\n",
    "pickle.dump(strongsymMonodentatesProj, file=open(\"strongsymMonodentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of Strong Sym Monodentate Complexes: \" + str(strongsymMonodentatesProj.getnnz()/2))\n",
    "pickle.dump(strongsymMonodentatesProj * spMonodentate, file=open(\"strongsymMonodentates.p\", \"wb\"))\n",
    "print(\"My Strongly Symmetric Complexes took \" + str(time.time() - start_time) + \"s to permute\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of \"5+1\"-symmetrical Monodentate Complexes: 163620.0\n",
      "My \"5+1\" Complexes took 37.696892976760864s to permute\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Generate fiveone Sym Matrix\n",
    "start_time = time.time()\n",
    "fiveonesymMonodentatesProj = np.zeros(lengths[0])\n",
    "fiveonesymMonodentatesProj[0] = 1\n",
    "fiveonesymMonodentatesProj[1] = 5\n",
    "fiveonesymMonodentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(fiveonesymMonodentatesProj))))\n",
    "pickle.dump(fiveonesymMonodentatesProj, file=open(\"fiveonesymMonodentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of \\\"5+1\\\"-symmetrical Monodentate Complexes: \" + str(fiveonesymMonodentatesProj.getnnz()/2))\n",
    "pickle.dump(fiveonesymMonodentatesProj * spMonodentate, file=open(\"fiveonesymMonodentates.p\", \"wb\"))\n",
    "print(\"My \\\"5+1\\\" Complexes took \" + str(time.time() - start_time) + \"s to permute\")\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of \"4+2\"-symmetrical Monodentate Complexes: 163620.0\n",
      "My \"4+2\" Complexes took 37.41836500167847s to permute\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Generate fourtwosym Matrix\n",
    "start_time = time.time()\n",
    "fourtwosymMonodentatesProj = np.zeros(lengths[0])\n",
    "fourtwosymMonodentatesProj[0] = 2\n",
    "fourtwosymMonodentatesProj[1] = 4\n",
    "fourtwosymMonodentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(fourtwosymMonodentatesProj))))\n",
    "pickle.dump(fourtwosymMonodentatesProj, file=open(\"fourtwosymMonodentatesProj.p\", \"wb\"), protocol=2)\n",
    "print(\"Number of \\\"4+2\\\"-symmetrical Monodentate Complexes: \" + str(fourtwosymMonodentatesProj.getnnz()/2))\n",
    "pickle.dump(fourtwosymMonodentatesProj * spMonodentate, file=open(\"fourtwosymMonodentates.p\", \"wb\"))\n",
    "print(\"My \\\"4+2\\\" Complexes took \" + str(time.time() - start_time) + \"s to permute\")\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "My eq asym mono Complexes took 16.601659536361694s to permute\n",
      "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 took 13816.263692378998\n"
     ]
    }
   ],
   "source": [
    "# Generate equatorially asym Matrix mono <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< DONE. added a 2'=3 matrix \n",
    "from sys import getsizeof\n",
    "start_time = time.time()\n",
    "eqasymMonodentatesProj = np.zeros(lengths[0] - 1) # minus 1 because we took out '2' and introduce it later by instertion to split up the calculation\n",
    "# first we thought we wouldnt need them bc they create degeneracies (2=2), but we need them since axial is different from eq.\n",
    "eqasymMonodentatesProj[0] = 2\n",
    "eqasymMonodentatesProj[1] = 2\n",
    "## eqasymMonodentatesProj[2] = 2\n",
    "## eqasymMonodentatesProj = sparse.csr_matrix(np.array(list(mit.distinct_permutations(eqasymMonodentatesProj))))\n",
    "# do this first, about 16 s\n",
    "eqasymMonodentatesProjBlock = np.array(list(mit.distinct_permutations(eqasymMonodentatesProj)))\n",
    "print(\"My eq asym mono Complexes took \" + str(time.time() - start_time) + \"s to permute\")\n",
    "\n",
    "# eqasymMonodentatesProjBlock is the permutation without the last \"s\", we initialize a proj mat and store every s-insertion into a *.p file.\n",
    "# we didnt have the proj * props here yet (before we'd need a vstack of all the block-proj)\n",
    "# => we run these lines below, see all output files in enum/eqasymMonodentatesProj. Took about 4 h.\n",
    "for k in range(0, np.shape(eqasymMonodentatesProjBlock)[1] + 1 ): # plus 1 because we also want an insertion after the last item: np.shape(eqasymMonodentatesProjBlock)[1] + 1 \n",
    "#     eqasymMonodentatesProj = sparse.csr_matrix(np.zeros(np.shape(eqasymMonodentatesProjBlock)[1] + 1)) # plus 1 because we also want an insertion after the last item\n",
    "    eqasymMonodentatesProjForRacsDistinguishable = sparse.csr_matrix(np.zeros(np.shape(eqasymMonodentatesProjBlock)[1] + 1))\n",
    "    for i in eqasymMonodentatesProjBlock:\n",
    "        eqasymMonodentatesProj = sparse.vstack([eqasymMonodentatesProj, sparse.csr_matrix(np.insert(i, k, 2))])\n",
    "        eqasymMonodentatesProjForRacsDistinguishable = sparse.vstack([eqasymMonodentatesProjForRacsDistinguishable, sparse.csr_matrix(np.insert(i, k, 3))])\n",
    "    pickle.dump(eqasymMonodentatesProj, file=open(\"eqasymMonodentatesProj/eqasymMonodentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"wb\"))\n",
    "    pickle.dump(eqasymMonodentatesProjForRacsDistinguishable, file=open(\"eqasymMonodentatesProj/eqasymMonodentatesProjForRacsDistinguishable_\" + str('{:03}'.format(k)) + \".p\", \"wb\"), protocol = 2)\n",
    "    print(k, end=' ')\n",
    "print('took ' + str(time.time() - start_time))\n",
    "\n",
    "# => we run these lines bellow, see all output files in enum/eqasymMonodentates. Took about 30 s.\n",
    "# for k in range(0, np.shape(eqasymMonodentatesProjBlock)[1] + 1): # this could be done in the loop above but we dont because we split it up np.shape(eqasymMonodentatesProjBlock)[1] + 1\n",
    "#     partial_eqasymMonodentatesProj = pickle.load( open(\"eqasymMonodentatesProj/eqasymMonodentatesProj_\" + str('{:03}'.format(k)) + \".p\", \"rb\" ) )\n",
    "#     pickle.dump(partial_eqasymMonodentatesProj * spMonodentate, file=open(\"eqasymMonodentates/eqasymMonodentates_\" + str('{:03}'.format(k)) + \".p\", \"wb\"))"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "# Extract number of atoms from gdb9 and add it to the lines to get the SMILES\n",
    "for i in *00000*xyz; do var=$( cat $i | sed -n 1p ) && head -$(($var+4)) $i | tail -1 | awk '{print $2}; done >> SMILESwSymbols &\n",
    "\n",
    "# Remove all special characters\n",
    "cat SMILESwSymbols | tr -d [@=\\)\\(#0-9H\\.] >> SMILESwoSymbols\n",
    "    \n",
    "# Count the heavy atoms in the SMILESwoSymbols\n",
    "for i in `cat SMILESwoSymbols`; do echo $i | wc -m; done >> SMILESlengths\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "code_folding": [
     0
    ],
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# # gdb9 analysis\n",
    "# import collections\n",
    "\n",
    "# gdb4 = \"CNOCCCNCOCCCOCCCCCNCCONCOCCCCCOCOCCCCCCOCCOCCCONNCONCCCCCCCOCCCCCCCNNCCNOCCCOCCNOCCOCCCCCCCCCCCNNCCNOCCCOCCNCCCOCNCOCOCOOCCOCCCCCCCOCCOCOCCOCCCCCCCOCNCCOCCCCCCCCCOC\"\n",
    "# c_gdb4 = collections.Counter(gdb4)\n",
    "# print(sorted(c_gdb4.items(), key=lambda c_gdb4: c_gdb4[0]))\n",
    "# print(gdb4)\n",
    "# print(\"\\n\")\n",
    "\n",
    "# slu1 = str()\n",
    "# # validDictMo can be CNO only if i just regex out the HSP ones. In diatoms I need to reassemble.\n",
    "# for name, prop in validDictMo.items():\n",
    "#     slu1 += re.sub('[\\]\\[\\+\\-HSP]','',name)\n",
    "# print(''.join(slu1))\n",
    "# c_slu1 = collections.Counter(slu1)\n",
    "# print(sorted(c_slu1.items(), key=lambda c_slu1: c_slu1[0]))\n",
    "# print(\"\\n\")\n",
    "\n",
    "# slu2 = str()\n",
    "# for name, prop in validDictDi.items():\n",
    "#     if 'P' in name or 'S' in name:\n",
    "#         continue\n",
    "#     else:\n",
    "#         slu2 += re.sub('[\\]\\[\\+\\-H]','',name)\n",
    "# print(''.join(slu2))\n",
    "# c_slu2 = collections.Counter(slu2)\n",
    "# print(sorted(c_slu2.items(), key=lambda c_slu2: c_slu2[0]))\n",
    "# print(\"\\n\")\n",
    "\n",
    "# slu4 = str()\n",
    "# for name, prop in dictBident.items():\n",
    "#     if 'P' in name or 'S' in name:\n",
    "#         continue\n",
    "#     else:\n",
    "#         slu4 += re.sub('[\\]\\[\\+\\-H]','',name)\n",
    "# print(''.join(slu4))\n",
    "# c_slu4 = collections.Counter(slu4)\n",
    "# print(sorted(c_slu4.items(), key=lambda c_slu4: c_slu4[0]))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "# plt.xlabel('Part Score')\n",
    "# plt.ylabel('Number of Ligands')\n",
    "# # plt.yscale('log', nonposy='clip')\n",
    "# plt.title('Histogram of Ca origianl ['+ components + \"]\")\n",
    "# plt.hist(histVsepr)\n",
    "# # plt.savefig('histCa' + components + \".pdf\", bbox_inches='tight')\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "# first version of scoring\n",
    "\n",
    "# ## only negatively charged ligands\n",
    "# outputListDiNeg = []\n",
    "# scoreDiNeg = []\n",
    "# for line in outputListDi:\n",
    "#     # only consider negatively charged di-heavy-atoms\n",
    "#     if line[4] <= 0 or line[13] <= 0:\n",
    "#         # higher is better\n",
    "#         scoreCharge = 3 if line[4] + line[13] >= -2 else line[4] + line[13] + 4\n",
    "#         scoreCharge -= 3 if line[4] + line[13] > 0 else 0\n",
    "\n",
    "#         usual1 = line[2] - 2*line[3] + line[4] - 2*line[5]\n",
    "#         usual2 = line[11] - 2*line[12] + line[13] - 2*line[14]\n",
    "#         scoreVsepr = 5-np.abs(usual1-usual2)\n",
    "        \n",
    "#         # THEY ARENT[[since both AB and BA is created, we remove the ones that are A=B]]\n",
    "#         # the first atom is the CA and we punish >=3 H on it.\n",
    "#         if line[5] == 4:\n",
    "#             scoreCa = 0\n",
    "#         elif line[5] == 3:\n",
    "#             scoreCa = 1\n",
    "#         else:\n",
    "#             scoreCa = 4\n",
    "        \n",
    "#         scoreClosedShell = int(not((line[2]+line[11])%2))\n",
    "\n",
    "#         score = (scoreCharge + scoreVsepr + scoreCa + 0.5 * line[8] + 0.5 * line[17])*scoreClosedShell\n",
    "#         scoreDiNeg.append(score)\n",
    "        \n",
    "#         outputListDiNeg.append([line,score])\n",
    "#     else:\n",
    "#         continue\n",
    "\n",
    "# # gives 5625 (total 15625 * 9/25, since there are 25 comb of [-2,+2], 9 of which contain a pos sign)    \n",
    "\n",
    "# # for s in outputListDiNeg:\n",
    "# #     print(*s)\n",
    "# k=0\n",
    "# score = np.zeros(len(outputListDiNeg))\n",
    "# for i in range(0, len(outputListDiNeg)):\n",
    "#     score[i] = outputListDiNeg[i][1]\n",
    "#     if score[i] > 3:\n",
    "#         k += 1\n",
    "# #         print(outputListDiNeg[i])\n",
    "# print(k)    \n",
    "\n",
    "# plt.xlabel('Score')\n",
    "# plt.ylabel('Number of Ligands')\n",
    "# plt.title('Histogram of Ligands ['+ components + \"]\")\n",
    "# plt.hist(score)\n",
    "# # plt.savefig('distr_' + components + \".pdf\", bbox_inches='tight')\n",
    "# plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "code_folding": [
     0
    ],
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# # plot the number of ligands sorted by the number of electrons (isoelectronic structures)\n",
    "\n",
    "# numBins = len(np.unique(isoList))\n",
    "\n",
    "# plt.hist(isoList, bins = numBins, facecolor='green')\n",
    "# plt.xlabel('Number of Electrons')\n",
    "# plt.ylabel('Number of Ligands')\n",
    "# plt.title('Histogram of Isoelectronic Ligands ['+ components + \"]\")\n",
    "# plt.xticks(np.unique(isoList))\n",
    "# # plt.savefig('hist_iso_ligands_' + components + \".pdf\", bbox_inches='tight')\n",
    "# plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "code_folding": [
     0
    ]
   },
   "outputs": [],
   "source": [
    "# # plot the number of ligands sorted by the number of VE (VE-isoelectronic structures)\n",
    "\n",
    "# numBins = len(np.unique(veList))\n",
    "\n",
    "# plt.hist(veList, bins = numBins, facecolor='green')\n",
    "# plt.xlabel('Number of Valence Electrons (VE) ['+ components + \"]\")\n",
    "# plt.ylabel('Number of Ligands')\n",
    "# plt.title('Histogram of Iso-VE-Ligands ['+ components + \"]\")\n",
    "# plt.xticks(np.unique(veList))\n",
    "# # plt.savefig('hist_isove_ligands_' + components + \".pdf\", bbox_inches='tight')\n",
    "# plt.show()\n"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Raw Cell Format",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
